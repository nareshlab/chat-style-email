"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mutative";
exports.ids = ["vendor-chunks/mutative"];
exports.modules = {

/***/ "(ssr)/./node_modules/mutative/dist/mutative.esm.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/mutative/dist/mutative.esm.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   castMutable: () => (/* binding */ castMutable),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   makeCreator: () => (/* binding */ makeCreator),\n/* harmony export */   markSimpleObject: () => (/* binding */ markSimpleObject),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   rawReturn: () => (/* binding */ rawReturn),\n/* harmony export */   unsafe: () => (/* binding */ unsafe)\n/* harmony export */ });\nconst Operation = {\n    Remove: 'remove',\n    Replace: 'replace',\n    Add: 'add',\n};\n\n// Don't use `Symbol()` just for 3rd party access the draft\nconst PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\nconst RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\nconst iteratorSymbol = Symbol.iterator;\nconst dataTypes = {\n    mutable: 'mutable',\n    immutable: 'immutable',\n};\n\nconst internal = {};\n\nfunction has(target, key) {\n    return target instanceof Map\n        ? target.has(key)\n        : Object.prototype.hasOwnProperty.call(target, key);\n}\nfunction getDescriptor(target, key) {\n    if (key in target) {\n        let prototype = Reflect.getPrototypeOf(target);\n        while (prototype) {\n            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\n            if (descriptor)\n                return descriptor;\n            prototype = Reflect.getPrototypeOf(prototype);\n        }\n    }\n    return;\n}\nfunction isBaseSetInstance(obj) {\n    return Object.getPrototypeOf(obj) === Set.prototype;\n}\nfunction isBaseMapInstance(obj) {\n    return Object.getPrototypeOf(obj) === Map.prototype;\n}\n\nfunction latest(proxyDraft) {\n    var _a;\n    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;\n}\n/**\n * Check if the value is a draft\n */\nfunction isDraft(target) {\n    return !!getProxyDraft(target);\n}\nfunction getProxyDraft(value) {\n    if (typeof value !== 'object')\n        return null;\n    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];\n}\nfunction getValue(value) {\n    var _a;\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;\n}\n/**\n * Check if a value is draftable\n */\nfunction isDraftable(value, options) {\n    if (!value || typeof value !== 'object')\n        return false;\n    let markResult;\n    return (Object.getPrototypeOf(value) === Object.prototype ||\n        Array.isArray(value) ||\n        value instanceof Map ||\n        value instanceof Set ||\n        (!!(options === null || options === void 0 ? void 0 : options.mark) &&\n            ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\n                typeof markResult === 'function')));\n}\nfunction getPath(target, path = []) {\n    if (Object.hasOwnProperty.call(target, 'key')) {\n        // check if the parent is a draft and the original value is not equal to the current value\n        const parentCopy = target.parent.copy;\n        const proxyDraft = getProxyDraft(get(parentCopy, target.key));\n        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {\n            return null;\n        }\n        const isSet = target.parent.type === 3 /* DraftType.Set */;\n        const key = isSet\n            ? Array.from(target.parent.setMap.keys()).indexOf(target.key)\n            : target.key;\n        // check if the key is still in the next state parent\n        if (!((isSet && parentCopy.size > key) || has(parentCopy, key)))\n            return null;\n        path.push(key);\n    }\n    if (target.parent) {\n        return getPath(target.parent, path);\n    }\n    // `target` is root draft.\n    path.reverse();\n    try {\n        // check if the path is valid\n        resolvePath(target.copy, path);\n    }\n    catch (e) {\n        return null;\n    }\n    return path;\n}\nfunction getType(target) {\n    if (Array.isArray(target))\n        return 1 /* DraftType.Array */;\n    if (target instanceof Map)\n        return 2 /* DraftType.Map */;\n    if (target instanceof Set)\n        return 3 /* DraftType.Set */;\n    return 0 /* DraftType.Object */;\n}\nfunction get(target, key) {\n    return getType(target) === 2 /* DraftType.Map */ ? target.get(key) : target[key];\n}\nfunction set(target, key, value) {\n    const type = getType(target);\n    if (type === 2 /* DraftType.Map */) {\n        target.set(key, value);\n    }\n    else {\n        target[key] = value;\n    }\n}\nfunction peek(target, key) {\n    const state = getProxyDraft(target);\n    const source = state ? latest(state) : target;\n    return source[key];\n}\nfunction isEqual(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\nfunction revokeProxy(proxyDraft) {\n    if (!proxyDraft)\n        return;\n    while (proxyDraft.finalities.revoke.length > 0) {\n        const revoke = proxyDraft.finalities.revoke.pop();\n        revoke();\n    }\n}\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\nfunction escapePath(path, pathAsArray) {\n    return pathAsArray\n        ? path\n        : ['']\n            .concat(path)\n            .map((_item) => {\n            const item = `${_item}`;\n            if (item.indexOf('/') === -1 && item.indexOf('~') === -1)\n                return item;\n            return item.replace(/~/g, '~0').replace(/\\//g, '~1');\n        })\n            .join('/');\n}\nfunction unescapePath(path) {\n    if (Array.isArray(path))\n        return path;\n    return path\n        .split('/')\n        .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\n        .slice(1);\n}\nfunction resolvePath(base, path) {\n    for (let index = 0; index < path.length - 1; index += 1) {\n        const key = path[index];\n        // use `index` in Set draft\n        base = get(getType(base) === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n        if (typeof base !== 'object') {\n            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\n        }\n    }\n    return base;\n}\n\nfunction strictCopy(target) {\n    const copy = Object.create(Object.getPrototypeOf(target));\n    Reflect.ownKeys(target).forEach((key) => {\n        let desc = Reflect.getOwnPropertyDescriptor(target, key);\n        if (desc.enumerable && desc.configurable && desc.writable) {\n            copy[key] = target[key];\n            return;\n        }\n        // for freeze\n        if (!desc.writable) {\n            desc.writable = true;\n            desc.configurable = true;\n        }\n        if (desc.get || desc.set)\n            desc = {\n                configurable: true,\n                writable: true,\n                enumerable: desc.enumerable,\n                value: target[key],\n            };\n        Reflect.defineProperty(copy, key, desc);\n    });\n    return copy;\n}\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\nfunction shallowCopy(original, options) {\n    let markResult;\n    if (Array.isArray(original)) {\n        return Array.prototype.concat.call(original);\n    }\n    else if (original instanceof Set) {\n        if (!isBaseSetInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original.values());\n        }\n        return Set.prototype.difference\n            ? Set.prototype.difference.call(original, new Set())\n            : new Set(original.values());\n    }\n    else if (original instanceof Map) {\n        if (!isBaseMapInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original);\n        }\n        return new Map(original);\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.mark) &&\n        ((markResult = options.mark(original, dataTypes)),\n            markResult !== undefined) &&\n        markResult !== dataTypes.mutable) {\n        if (markResult === dataTypes.immutable) {\n            return strictCopy(original);\n        }\n        else if (typeof markResult === 'function') {\n            if ((options.enablePatches || options.enableAutoFreeze)) {\n                throw new Error(`You can't use mark and patches or auto freeze together.`);\n            }\n            return markResult();\n        }\n        throw new Error(`Unsupported mark result: ${markResult}`);\n    }\n    else if (typeof original === 'object' &&\n        Object.getPrototypeOf(original) === Object.prototype) {\n        // For best performance with shallow copies,\n        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\n        const copy = {};\n        Object.keys(original).forEach((key) => {\n            copy[key] = original[key];\n        });\n        Object.getOwnPropertySymbols(original).forEach((key) => {\n            if (propIsEnum.call(original, key)) {\n                copy[key] = original[key];\n            }\n        });\n        return copy;\n    }\n    else {\n        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);\n    }\n}\nfunction ensureShallowCopy(target) {\n    if (target.copy)\n        return;\n    target.copy = shallowCopy(target.original, target.options);\n}\nfunction deepClone(target) {\n    if (!isDraftable(target))\n        return getValue(target);\n    if (Array.isArray(target))\n        return target.map(deepClone);\n    if (target instanceof Map) {\n        const iterable = Array.from(target.entries()).map(([k, v]) => [\n            k,\n            deepClone(v),\n        ]);\n        if (!isBaseMapInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Map(iterable);\n    }\n    if (target instanceof Set) {\n        const iterable = Array.from(target).map(deepClone);\n        if (!isBaseSetInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Set(iterable);\n    }\n    const copy = Object.create(Object.getPrototypeOf(target));\n    for (const key in target)\n        copy[key] = deepClone(target[key]);\n    return copy;\n}\nfunction cloneIfNeeded(target) {\n    return isDraft(target) ? deepClone(target) : target;\n}\n\nfunction markChanged(proxyDraft) {\n    var _a;\n    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n    if (!proxyDraft.operated) {\n        proxyDraft.operated = true;\n        if (proxyDraft.parent) {\n            markChanged(proxyDraft.parent);\n        }\n    }\n}\n\nfunction throwFrozenError() {\n    throw new Error('Cannot modify frozen object');\n}\nfunction deepFreeze(target, subKey, updatedValues, stack, keys) {\n    {\n        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();\n        stack = stack !== null && stack !== void 0 ? stack : [];\n        keys = keys !== null && keys !== void 0 ? keys : [];\n        const value = updatedValues.has(target)\n            ? updatedValues.get(target)\n            : target;\n        if (stack.length > 0) {\n            const index = stack.indexOf(value);\n            if (value && typeof value === 'object' && index !== -1) {\n                if (stack[0] === value) {\n                    throw new Error(`Forbids circular reference`);\n                }\n                throw new Error(`Forbids circular reference: ~/${keys\n                    .slice(0, index)\n                    .map((key, index) => {\n                    if (typeof key === 'symbol')\n                        return `[${key.toString()}]`;\n                    const parent = stack[index];\n                    if (typeof key === 'object' &&\n                        (parent instanceof Map || parent instanceof Set))\n                        return Array.from(parent.keys()).indexOf(key);\n                    return key;\n                })\n                    .join('/')}`);\n            }\n            stack.push(value);\n            keys.push(subKey);\n        }\n        else {\n            stack.push(value);\n        }\n    }\n    if (Object.isFrozen(target) || isDraft(target)) {\n        {\n            stack.pop();\n            keys.pop();\n        }\n        return;\n    }\n    const type = getType(target);\n    switch (type) {\n        case 2 /* DraftType.Map */:\n            for (const [key, value] of target) {\n                deepFreeze(key, key, updatedValues, stack, keys);\n                deepFreeze(value, key, updatedValues, stack, keys);\n            }\n            target.set = target.clear = target.delete = throwFrozenError;\n            break;\n        case 3 /* DraftType.Set */:\n            for (const value of target) {\n                deepFreeze(value, value, updatedValues, stack, keys);\n            }\n            target.add = target.clear = target.delete = throwFrozenError;\n            break;\n        case 1 /* DraftType.Array */:\n            Object.freeze(target);\n            let index = 0;\n            for (const value of target) {\n                deepFreeze(value, index, updatedValues, stack, keys);\n                index += 1;\n            }\n            break;\n        default:\n            Object.freeze(target);\n            // ignore non-enumerable or symbol properties\n            Object.keys(target).forEach((name) => {\n                const value = target[name];\n                deepFreeze(value, name, updatedValues, stack, keys);\n            });\n    }\n    {\n        stack.pop();\n        keys.pop();\n    }\n}\n\nfunction forEach(target, iter) {\n    const type = getType(target);\n    if (type === 0 /* DraftType.Object */) {\n        Reflect.ownKeys(target).forEach((key) => {\n            iter(key, target[key], target);\n        });\n    }\n    else if (type === 1 /* DraftType.Array */) {\n        let index = 0;\n        for (const entry of target) {\n            iter(index, entry, target);\n            index += 1;\n        }\n    }\n    else {\n        target.forEach((entry, index) => iter(index, entry, target));\n    }\n}\n\nfunction handleValue(target, handledSet, options) {\n    if (isDraft(target) ||\n        !isDraftable(target, options) ||\n        handledSet.has(target) ||\n        Object.isFrozen(target))\n        return;\n    const isSet = target instanceof Set;\n    const setMap = isSet ? new Map() : undefined;\n    handledSet.add(target);\n    forEach(target, (key, value) => {\n        var _a;\n        if (isDraft(value)) {\n            const proxyDraft = getProxyDraft(value);\n            ensureShallowCopy(proxyDraft);\n            // A draft where a child node has been changed, or assigned a value\n            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original;\n            // final update value\n            set(isSet ? setMap : target, key, updatedValue);\n        }\n        else {\n            handleValue(value, handledSet, options);\n        }\n    });\n    if (setMap) {\n        const set = target;\n        const values = Array.from(set);\n        set.clear();\n        values.forEach((value) => {\n            set.add(setMap.has(value) ? setMap.get(value) : value);\n        });\n    }\n}\nfunction finalizeAssigned(proxyDraft, key) {\n    // handle the draftable assigned values， and the value is not a draft\n    const copy = proxyDraft.type === 3 /* DraftType.Set */ ? proxyDraft.setMap : proxyDraft.copy;\n    if (proxyDraft.finalities.revoke.length > 1 &&\n        proxyDraft.assignedMap.get(key) &&\n        copy) {\n        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);\n    }\n}\nfunction finalizeSetValue(target) {\n    if (target.type === 3 /* DraftType.Set */ && target.copy) {\n        target.copy.clear();\n        target.setMap.forEach((value) => {\n            target.copy.add(getValue(value));\n        });\n    }\n}\nfunction finalizePatches(target, generatePatches, patches, inversePatches) {\n    const shouldFinalize = target.operated &&\n        target.assignedMap &&\n        target.assignedMap.size > 0 &&\n        !target.finalized;\n    if (shouldFinalize) {\n        if (patches && inversePatches) {\n            const basePath = getPath(target);\n            if (basePath) {\n                generatePatches(target, basePath, patches, inversePatches);\n            }\n        }\n        target.finalized = true;\n    }\n}\nfunction markFinalization(target, key, value, generatePatches) {\n    const proxyDraft = getProxyDraft(value);\n    if (proxyDraft) {\n        // !case: assign the draft value\n        if (!proxyDraft.callbacks) {\n            proxyDraft.callbacks = [];\n        }\n        proxyDraft.callbacks.push((patches, inversePatches) => {\n            var _a;\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.copy) {\n                    updatedValue = proxyDraft.copy;\n                }\n                finalizeSetValue(target);\n                finalizePatches(target, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n        });\n        if (target.options.enableAutoFreeze) {\n            // !case: assign the draft value in cross draft tree\n            if (proxyDraft.finalities !== target.finalities) {\n                target.options.enableAutoFreeze = false;\n            }\n        }\n    }\n    if (isDraftable(value, target.options)) {\n        // !case: assign the non-draft value\n        target.finalities.draft.push(() => {\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                finalizeAssigned(target, key);\n            }\n        });\n    }\n}\n\nfunction generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {\n    let { original, assignedMap, options } = proxyState;\n    let copy = proxyState.copy;\n    if (copy.length < original.length) {\n        [original, copy] = [copy, original];\n        [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let index = 0; index < original.length; index += 1) {\n        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(copy[index]),\n            });\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(original[index]),\n            });\n        }\n    }\n    for (let index = original.length; index < copy.length; index += 1) {\n        const _path = basePath.concat([index]);\n        const path = escapePath(_path, pathAsArray);\n        patches.push({\n            op: Operation.Add,\n            path,\n            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n            value: cloneIfNeeded(copy[index]),\n        });\n    }\n    if (original.length < copy.length) {\n        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\n        // For performance, here we only generate an operation that replaces the length of the array,\n        // which is inconsistent with JSON Patch specification\n        const { arrayLengthAssignment = true } = options.enablePatches;\n        if (arrayLengthAssignment) {\n            const _path = basePath.concat(['length']);\n            const path = escapePath(_path, pathAsArray);\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                value: original.length,\n            });\n        }\n        else {\n            for (let index = copy.length; original.length < index; index -= 1) {\n                const _path = basePath.concat([index - 1]);\n                const path = escapePath(_path, pathAsArray);\n                inversePatches.push({\n                    op: Operation.Remove,\n                    path,\n                });\n            }\n        }\n    }\n}\nfunction generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {\n    assignedMap.forEach((assignedValue, key) => {\n        const originalValue = get(original, key);\n        const value = cloneIfNeeded(get(copy, key));\n        const op = !assignedValue\n            ? Operation.Remove\n            : has(original, key)\n                ? Operation.Replace\n                : Operation.Add;\n        if (isEqual(originalValue, value) && op === Operation.Replace)\n            return;\n        const _path = basePath.concat(key);\n        const path = escapePath(_path, pathAsArray);\n        patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\n        inversePatches.push(op === Operation.Add\n            ? { op: Operation.Remove, path }\n            : op === Operation.Remove\n                ? { op: Operation.Add, path, value: originalValue }\n                : { op: Operation.Replace, path, value: originalValue });\n    });\n}\nfunction generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {\n    let index = 0;\n    original.forEach((value) => {\n        if (!copy.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Add,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n    index = 0;\n    copy.forEach((value) => {\n        if (!original.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Add,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n}\nfunction generatePatches(proxyState, basePath, patches, inversePatches) {\n    const { pathAsArray = true } = proxyState.options.enablePatches;\n    switch (proxyState.type) {\n        case 0 /* DraftType.Object */:\n        case 2 /* DraftType.Map */:\n            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 1 /* DraftType.Array */:\n            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 3 /* DraftType.Set */:\n            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n    }\n}\n\nlet readable = false;\nconst checkReadable = (value, options, ignoreCheckDraftable = false) => {\n    if (typeof value === 'object' &&\n        value !== null &&\n        (!isDraftable(value, options) || ignoreCheckDraftable) &&\n        !readable) {\n        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);\n    }\n};\n/**\n * `unsafe(callback)` to access mutable data directly in strict mode.\n *\n * ## Example\n *\n * ```ts\n * import { create, unsafe } from '../index';\n *\n * class Foobar {\n *   bar = 1;\n * }\n *\n * const baseState = { foobar: new Foobar() };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *    unsafe(() => {\n *      draft.foobar.bar = 2;\n *    });\n *   },\n *   {\n *     strict: true,\n *   }\n * );\n *\n * expect(state).toBe(baseState);\n * expect(state.foobar).toBe(baseState.foobar);\n * expect(state.foobar.bar).toBe(2);\n * ```\n */\nfunction unsafe(callback) {\n    readable = true;\n    let result;\n    try {\n        result = callback();\n    }\n    finally {\n        readable = false;\n    }\n    return result;\n}\n\nconst mapHandler = {\n    get size() {\n        const current = latest(getProxyDraft(this));\n        return current.size;\n    },\n    has(key) {\n        return latest(getProxyDraft(this)).has(key);\n    },\n    set(key, value) {\n        const target = getProxyDraft(this);\n        const source = latest(target);\n        if (!source.has(key) || !isEqual(source.get(key), value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, true);\n            target.copy.set(key, value);\n            markFinalization(target, key, value, generatePatches);\n        }\n        return this;\n    },\n    delete(key) {\n        if (!this.has(key)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (target.original.has(key)) {\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap.delete(key);\n        }\n        target.copy.delete(key);\n        return true;\n    },\n    clear() {\n        const target = getProxyDraft(this);\n        if (!this.size)\n            return;\n        ensureShallowCopy(target);\n        markChanged(target);\n        target.assignedMap = new Map();\n        for (const [key] of target.original) {\n            target.assignedMap.set(key, false);\n        }\n        target.copy.clear();\n    },\n    forEach(callback, thisArg) {\n        const target = getProxyDraft(this);\n        latest(target).forEach((_value, _key) => {\n            callback.call(thisArg, this.get(_key), _key, this);\n        });\n    },\n    get(key) {\n        var _a, _b;\n        const target = getProxyDraft(this);\n        const value = latest(target).get(key);\n        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n        if (target.options.strict) {\n            checkReadable(value, target.options, mutable);\n        }\n        if (mutable) {\n            return value;\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // drafted or reassigned\n        if (value !== target.original.get(key)) {\n            return value;\n        }\n        const draft = internal.createDraft({\n            original: value,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        ensureShallowCopy(target);\n        target.copy.set(key, draft);\n        return draft;\n    },\n    keys() {\n        return latest(getProxyDraft(this)).keys();\n    },\n    values() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.values(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value,\n                };\n            },\n        };\n    },\n    entries() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.entries(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value: [result.value, value],\n                };\n            },\n        };\n    },\n    [iteratorSymbol]() {\n        return this.entries();\n    },\n};\nconst mapHandlerKeys = Reflect.ownKeys(mapHandler);\n\nconst getNextIterator = (target, iterator, { isValuesIterator }) => () => {\n    var _a, _b;\n    const result = iterator.next();\n    if (result.done)\n        return result;\n    const key = result.value;\n    let value = target.setMap.get(key);\n    const currentDraft = getProxyDraft(value);\n    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n    if (target.options.strict) {\n        checkReadable(key, target.options, mutable);\n    }\n    if (!mutable &&\n        !currentDraft &&\n        isDraftable(key, target.options) &&\n        !target.finalized &&\n        target.original.has(key)) {\n        // draft a draftable original set item\n        const proxy = internal.createDraft({\n            original: key,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        target.setMap.set(key, proxy);\n        value = proxy;\n    }\n    else if (currentDraft) {\n        // drafted\n        value = currentDraft.proxy;\n    }\n    return {\n        done: false,\n        value: isValuesIterator ? value : [value, value],\n    };\n};\nconst setHandler = {\n    get size() {\n        const target = getProxyDraft(this);\n        return target.setMap.size;\n    },\n    has(value) {\n        const target = getProxyDraft(this);\n        // reassigned or non-draftable values\n        if (target.setMap.has(value))\n            return true;\n        ensureShallowCopy(target);\n        const valueProxyDraft = getProxyDraft(value);\n        // drafted\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))\n            return true;\n        return false;\n    },\n    add(value) {\n        const target = getProxyDraft(this);\n        if (!this.has(value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(value, true);\n            target.setMap.set(value, value);\n            markFinalization(target, value, value, generatePatches);\n        }\n        return this;\n    },\n    delete(value) {\n        if (!this.has(value)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        const valueProxyDraft = getProxyDraft(value);\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {\n            // delete drafted\n            target.assignedMap.set(valueProxyDraft.original, false);\n            return target.setMap.delete(valueProxyDraft.original);\n        }\n        if (!valueProxyDraft && target.setMap.has(value)) {\n            // non-draftable values\n            target.assignedMap.set(value, false);\n        }\n        else {\n            // reassigned\n            target.assignedMap.delete(value);\n        }\n        // delete reassigned or non-draftable values\n        return target.setMap.delete(value);\n    },\n    clear() {\n        if (!this.size)\n            return;\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        for (const value of target.original) {\n            target.assignedMap.set(value, false);\n        }\n        target.setMap.clear();\n    },\n    values() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.values(),\n            next: getNextIterator(target, iterator, { isValuesIterator: true }),\n        };\n    },\n    entries() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.entries(),\n            next: getNextIterator(target, iterator, {\n                isValuesIterator: false,\n            }),\n        };\n    },\n    keys() {\n        return this.values();\n    },\n    [iteratorSymbol]() {\n        return this.values();\n    },\n    forEach(callback, thisArg) {\n        const iterator = this.values();\n        let result = iterator.next();\n        while (!result.done) {\n            callback.call(thisArg, result.value, result.value, this);\n            result = iterator.next();\n        }\n    },\n};\nif (Set.prototype.difference) {\n    // for compatibility with new Set methods\n    // https://github.com/tc39/proposal-set-methods\n    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.\n    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.\n    Object.assign(setHandler, {\n        intersection(other) {\n            return Set.prototype.intersection.call(new Set(this.values()), other);\n        },\n        union(other) {\n            return Set.prototype.union.call(new Set(this.values()), other);\n        },\n        difference(other) {\n            return Set.prototype.difference.call(new Set(this.values()), other);\n        },\n        symmetricDifference(other) {\n            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);\n        },\n        isSubsetOf(other) {\n            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\n        },\n        isSupersetOf(other) {\n            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\n        },\n        isDisjointFrom(other) {\n            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\n        },\n    });\n}\nconst setHandlerKeys = Reflect.ownKeys(setHandler);\n\nconst draftsCache = new WeakSet();\nconst proxyHandler = {\n    get(target, key, receiver) {\n        var _a, _b;\n        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];\n        // Improve draft reading performance by caching the draft copy.\n        if (copy && draftsCache.has(copy)) {\n            return copy;\n        }\n        if (key === PROXY_DRAFT)\n            return target;\n        let markResult;\n        if (target.options.mark) {\n            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\n            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\n            const value = key === 'size' &&\n                (target.original instanceof Map || target.original instanceof Set)\n                ? Reflect.get(target.original, key)\n                : Reflect.get(target.original, key, receiver);\n            markResult = target.options.mark(value, dataTypes);\n            if (markResult === dataTypes.mutable) {\n                if (target.options.strict) {\n                    checkReadable(value, target.options, true);\n                }\n                return value;\n            }\n        }\n        const source = latest(target);\n        if (source instanceof Map && mapHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);\n            }\n            const handle = mapHandler[key];\n            if (handle) {\n                return handle.bind(target.proxy);\n            }\n        }\n        if (source instanceof Set && setHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);\n            }\n            const handle = setHandler[key];\n            if (handle) {\n                return handle.bind(target.proxy);\n            }\n        }\n        if (!has(source, key)) {\n            const desc = getDescriptor(source, key);\n            return desc\n                ? `value` in desc\n                    ? desc.value\n                    : // !case: support for getter\n                        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)\n                : undefined;\n        }\n        const value = source[key];\n        if (target.options.strict) {\n            checkReadable(value, target.options);\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // Ensure that the assigned values are not drafted\n        if (value === peek(target.original, key)) {\n            ensureShallowCopy(target);\n            target.copy[key] = createDraft({\n                original: target.original[key],\n                parentDraft: target,\n                key: target.type === 1 /* DraftType.Array */ ? Number(key) : key,\n                finalities: target.finalities,\n                options: target.options,\n            });\n            // !case: support for custom shallow copy function\n            if (typeof markResult === 'function') {\n                const subProxyDraft = getProxyDraft(target.copy[key]);\n                ensureShallowCopy(subProxyDraft);\n                // Trigger a custom shallow copy to update to a new copy\n                markChanged(subProxyDraft);\n                return subProxyDraft.copy;\n            }\n            return target.copy[key];\n        }\n        return value;\n    },\n    set(target, key, value) {\n        var _a;\n        if (target.type === 3 /* DraftType.Set */ || target.type === 2 /* DraftType.Map */) {\n            throw new Error(`Map/Set draft does not support any property assignment.`);\n        }\n        let _key;\n        if (target.type === 1 /* DraftType.Array */ &&\n            key !== 'length' &&\n            !(Number.isInteger((_key = Number(key))) &&\n                _key >= 0 &&\n                (key === 0 || _key === 0 || String(_key) === String(key)))) {\n            throw new Error(`Only supports setting array indices and the 'length' property.`);\n        }\n        const desc = getDescriptor(latest(target), key);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // !case: cover the case of setter\n            desc.set.call(target.proxy, value);\n            return true;\n        }\n        const current = peek(latest(target), key);\n        const currentProxyDraft = getProxyDraft(current);\n        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n            // !case: ignore the case of assigning the original draftable value to a draft\n            target.copy[key] = value;\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            target.assignedMap.set(key, false);\n            return true;\n        }\n        // !case: handle new props with value 'undefined'\n        if (isEqual(value, current) &&\n            (value !== undefined || has(target.original, key)))\n            return true;\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (has(target.original, key) && isEqual(value, target.original[key])) {\n            // !case: handle the case of assigning the original non-draftable value to a draft\n            target.assignedMap.delete(key);\n        }\n        else {\n            target.assignedMap.set(key, true);\n        }\n        target.copy[key] = value;\n        markFinalization(target, key, value, generatePatches);\n        return true;\n    },\n    has(target, key) {\n        return key in latest(target);\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(latest(target));\n    },\n    getOwnPropertyDescriptor(target, key) {\n        const source = latest(target);\n        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n        if (!descriptor)\n            return descriptor;\n        return {\n            writable: true,\n            configurable: target.type !== 1 /* DraftType.Array */ || key !== 'length',\n            enumerable: descriptor.enumerable,\n            value: source[key],\n        };\n    },\n    getPrototypeOf(target) {\n        return Reflect.getPrototypeOf(target.original);\n    },\n    setPrototypeOf() {\n        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\n    },\n    defineProperty() {\n        throw new Error(`Cannot call 'defineProperty()' on drafts`);\n    },\n    deleteProperty(target, key) {\n        var _a;\n        if (target.type === 1 /* DraftType.Array */) {\n            return proxyHandler.set.call(this, target, key, undefined, target.proxy);\n        }\n        if (peek(target.original, key) !== undefined || key in target.original) {\n            // !case: delete an existing key\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            // The original non-existent key has been deleted\n            target.assignedMap.delete(key);\n        }\n        if (target.copy)\n            delete target.copy[key];\n        return true;\n    },\n};\nfunction createDraft(createDraftOptions) {\n    const { original, parentDraft, key, finalities, options } = createDraftOptions;\n    const type = getType(original);\n    const proxyDraft = {\n        type,\n        finalized: false,\n        parent: parentDraft,\n        original,\n        copy: null,\n        proxy: null,\n        finalities,\n        options,\n        // Mapping of draft Set items to their corresponding draft values.\n        setMap: type === 3 /* DraftType.Set */\n            ? new Map(original.entries())\n            : undefined,\n    };\n    // !case: undefined as a draft map key\n    if (key || 'key' in createDraftOptions) {\n        proxyDraft.key = key;\n    }\n    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */ ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);\n    finalities.revoke.push(revoke);\n    draftsCache.add(proxy);\n    proxyDraft.proxy = proxy;\n    if (parentDraft) {\n        const target = parentDraft;\n        target.finalities.draft.push((patches, inversePatches) => {\n            var _a, _b;\n            const oldProxyDraft = getProxyDraft(proxy);\n            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\n            let copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            const draft = get(copy, key);\n            const proxyDraft = getProxyDraft(draft);\n            if (proxyDraft) {\n                // assign the updated value to the copy object\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.operated) {\n                    updatedValue = getValue(draft);\n                }\n                finalizeSetValue(proxyDraft);\n                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n            // !case: handle the deleted key\n            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {\n                callback(patches, inversePatches);\n            });\n        });\n    }\n    else {\n        // !case: handle the root draft\n        const target = getProxyDraft(proxy);\n        target.finalities.draft.push((patches, inversePatches) => {\n            finalizeSetValue(target);\n            finalizePatches(target, generatePatches, patches, inversePatches);\n        });\n    }\n    return proxy;\n}\ninternal.createDraft = createDraft;\nfunction finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {\n    var _a;\n    const proxyDraft = getProxyDraft(result);\n    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;\n    const hasReturnedValue = !!returnedValue.length;\n    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {\n        while (proxyDraft.finalities.draft.length > 0) {\n            const finalize = proxyDraft.finalities.draft.pop();\n            finalize(patches, inversePatches);\n        }\n    }\n    const state = hasReturnedValue\n        ? returnedValue[0]\n        : proxyDraft\n            ? proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original\n            : result;\n    if (proxyDraft)\n        revokeProxy(proxyDraft);\n    if (enableAutoFreeze) {\n        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);\n    }\n    return [\n        state,\n        patches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\n            : patches,\n        inversePatches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: original }]\n            : inversePatches,\n    ];\n}\n\nfunction draftify(baseState, options) {\n    var _a;\n    const finalities = {\n        draft: [],\n        revoke: [],\n        handledSet: new WeakSet(),\n    };\n    let patches;\n    let inversePatches;\n    if (options.enablePatches) {\n        patches = [];\n        inversePatches = [];\n    }\n    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable ||\n        !isDraftable(baseState, options);\n    const draft = isMutable\n        ? baseState\n        : createDraft({\n            original: baseState,\n            parentDraft: null,\n            finalities,\n            options,\n        });\n    return [\n        draft,\n        (returnedValue = []) => {\n            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);\n            return (options.enablePatches\n                ? [finalizedState, finalizedPatches, finalizedInversePatches]\n                : finalizedState);\n        },\n    ];\n}\n\nfunction handleReturnValue(options) {\n    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\n    forEach(value, (key, item, source) => {\n        const proxyDraft = getProxyDraft(item);\n        // just handle the draft which is created by the same rootDraft\n        if (proxyDraft &&\n            rootDraft &&\n            proxyDraft.finalities === rootDraft.finalities) {\n            options.isContainDraft = true;\n            const currentValue = proxyDraft.original;\n            // final update value, but just handle return value\n            if (source instanceof Set) {\n                const arr = Array.from(source);\n                source.clear();\n                arr.forEach((_item) => source.add(key === _item ? currentValue : _item));\n            }\n            else {\n                set(source, key, currentValue);\n            }\n        }\n        else if (typeof item === 'object' && item !== null) {\n            options.value = item;\n            options.isRoot = false;\n            handleReturnValue(options);\n        }\n    });\n    if (isRoot) {\n        if (!options.isContainDraft)\n            console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);\n        if (useRawReturn) {\n            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);\n        }\n    }\n}\nfunction getCurrent(target) {\n    var _a;\n    const proxyDraft = getProxyDraft(target);\n    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))\n        return target;\n    const type = getType(target);\n    if (proxyDraft && !proxyDraft.operated)\n        return proxyDraft.original;\n    let currentValue;\n    function ensureShallowCopy() {\n        currentValue =\n            type === 2 /* DraftType.Map */\n                ? !isBaseMapInstance(target)\n                    ? new (Object.getPrototypeOf(target).constructor)(target)\n                    : new Map(target)\n                : type === 3 /* DraftType.Set */\n                    ? Array.from(proxyDraft.setMap.values())\n                    : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);\n    }\n    if (proxyDraft) {\n        // It's a proxy draft, let's create a shallow copy eagerly\n        proxyDraft.finalized = true;\n        try {\n            ensureShallowCopy();\n        }\n        finally {\n            proxyDraft.finalized = false;\n        }\n    }\n    else {\n        // It's not a proxy draft, let's use the target directly and let's see\n        // lazily if we need to create a shallow copy\n        currentValue = target;\n    }\n    forEach(currentValue, (key, value) => {\n        if (proxyDraft && isEqual(get(proxyDraft.original, key), value))\n            return;\n        const newValue = getCurrent(value);\n        if (newValue !== value) {\n            if (currentValue === target)\n                ensureShallowCopy();\n            set(currentValue, key, newValue);\n        }\n    });\n    if (type === 3 /* DraftType.Set */) {\n        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;\n        return !isBaseSetInstance(value)\n            ? new (Object.getPrototypeOf(value).constructor)(currentValue)\n            : new Set(currentValue);\n    }\n    return currentValue;\n}\nfunction current(target) {\n    if (!isDraft(target)) {\n        throw new Error(`current() is only used for Draft, parameter: ${target}`);\n    }\n    return getCurrent(target);\n}\n\n/**\n * `makeCreator(options)` to make a creator function.\n *\n * ## Example\n *\n * ```ts\n * import { makeCreator } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const create = makeCreator({ enableAutoFreeze: true });\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * expect(Object.isFrozen(state)).toBeTruthy();\n * ```\n */\nconst makeCreator = (arg) => {\n    if (arg !== undefined &&\n        Object.prototype.toString.call(arg) !== '[object Object]') {\n        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);\n    }\n    return function create(arg0, arg1, arg2) {\n        var _a, _b, _c;\n        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\n            return function (base, ...args) {\n                return create(base, (draft) => arg0.call(this, draft, ...args), arg1);\n            };\n        }\n        const base = arg0;\n        const mutate = arg1;\n        let options = arg2;\n        if (typeof arg1 !== 'function') {\n            options = arg1;\n        }\n        if (options !== undefined &&\n            Object.prototype.toString.call(options) !== '[object Object]') {\n            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);\n        }\n        options = Object.assign(Object.assign({}, arg), options);\n        const state = isDraft(base) ? current(base) : base;\n        const mark = Array.isArray(options.mark)\n            ? ((value, types) => {\n                for (const mark of options.mark) {\n                    if (typeof mark !== 'function') {\n                        throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);\n                    }\n                    const result = mark(value, types);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return;\n            })\n            : options.mark;\n        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;\n        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;\n        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;\n        const _options = {\n            enableAutoFreeze,\n            mark,\n            strict,\n            enablePatches,\n        };\n        if (!isDraftable(state, _options) &&\n            typeof state === 'object' &&\n            state !== null) {\n            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n        }\n        const [draft, finalize] = draftify(state, _options);\n        if (typeof arg1 !== 'function') {\n            if (!isDraftable(state, _options)) {\n                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n            }\n            return [draft, finalize];\n        }\n        let result;\n        try {\n            result = mutate(draft);\n        }\n        catch (error) {\n            revokeProxy(getProxyDraft(draft));\n            throw error;\n        }\n        const returnValue = (value) => {\n            const proxyDraft = getProxyDraft(draft);\n            if (!isDraft(value)) {\n                if (value !== undefined &&\n                    !isEqual(value, draft) &&\n                    (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {\n                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);\n                }\n                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];\n                if (rawReturnValue) {\n                    const _value = rawReturnValue[0];\n                    if (_options.strict && typeof value === 'object' && value !== null) {\n                        handleReturnValue({\n                            rootDraft: proxyDraft,\n                            value,\n                            useRawReturn: true,\n                        });\n                    }\n                    return finalize([_value]);\n                }\n                if (value !== undefined) {\n                    if (typeof value === 'object' && value !== null) {\n                        handleReturnValue({ rootDraft: proxyDraft, value });\n                    }\n                    return finalize([value]);\n                }\n            }\n            if (value === draft || value === undefined) {\n                return finalize([]);\n            }\n            const returnedProxyDraft = getProxyDraft(value);\n            if (_options === returnedProxyDraft.options) {\n                if (returnedProxyDraft.operated) {\n                    throw new Error(`Cannot return a modified child draft.`);\n                }\n                return finalize([current(value)]);\n            }\n            return finalize([value]);\n        };\n        if (result instanceof Promise) {\n            return result.then(returnValue, (error) => {\n                revokeProxy(getProxyDraft(draft));\n                throw error;\n            });\n        }\n        return returnValue(result);\n    };\n};\n\n/**\n * `create(baseState, callback, options)` to create the next state\n *\n * ## Example\n *\n * ```ts\n * import { create } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * ```\n */\nconst create = makeCreator();\n\n/**\n * `apply(state, patches)` to apply patches to state\n *\n * ## Example\n *\n * ```ts\n * import { create, apply } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const [state, patches] = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n *   { enablePatches: true }\n * );\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\n * expect(state).toEqual(apply(baseState, patches));\n * ```\n */\nfunction apply(state, patches, applyOptions) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i -= 1) {\n        const { value, op, path } = patches[i];\n        if ((!path.length && op === Operation.Replace) ||\n            (path === '' && op === Operation.Add)) {\n            state = value;\n            break;\n        }\n    }\n    if (i > -1) {\n        patches = patches.slice(i + 1);\n    }\n    const mutate = (draft) => {\n        patches.forEach((patch) => {\n            const { path: _path, op } = patch;\n            const path = unescapePath(_path);\n            let base = draft;\n            for (let index = 0; index < path.length - 1; index += 1) {\n                const parentType = getType(base);\n                let key = path[index];\n                if (typeof key !== 'string' && typeof key !== 'number') {\n                    key = String(key);\n                }\n                if (((parentType === 0 /* DraftType.Object */ ||\n                    parentType === 1 /* DraftType.Array */) &&\n                    (key === '__proto__' || key === 'constructor')) ||\n                    (typeof base === 'function' && key === 'prototype')) {\n                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);\n                }\n                // use `index` in Set draft\n                base = get(parentType === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n                if (typeof base !== 'object') {\n                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\n                }\n            }\n            const type = getType(base);\n            // ensure the original patch is not modified.\n            const value = deepClone(patch.value);\n            const key = path[path.length - 1];\n            switch (op) {\n                case Operation.Replace:\n                    switch (type) {\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            throw new Error(`Cannot apply replace patch to set.`);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Add:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            // If the \"-\" character is used to\n                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\n                            // this has the effect of appending the value to the array.\n                            return key === '-'\n                                ? base.push(value)\n                                : base.splice(key, 0, value);\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            return base.add(value);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Remove:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            return base.splice(key, 1);\n                        case 2 /* DraftType.Map */:\n                            return base.delete(key);\n                        case 3 /* DraftType.Set */:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    throw new Error(`Unsupported patch operation: ${op}.`);\n            }\n        });\n    };\n    if (isDraft(state)) {\n        if (applyOptions !== undefined) {\n            throw new Error(`Cannot apply patches with options to a draft.`);\n        }\n        mutate(state);\n        return state;\n    }\n    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), { enablePatches: false }));\n}\n\n/**\n * `original(draft)` to get original state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, original } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\n *   }\n * );\n * ```\n */\nfunction original(target) {\n    const proxyDraft = getProxyDraft(target);\n    if (!proxyDraft) {\n        throw new Error(`original() is only used for a draft, parameter: ${target}`);\n    }\n    return proxyDraft.original;\n}\n\n/**\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\n *\n * ## Example\n *\n * ```ts\n * import { create, rawReturn } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     return rawReturn(baseState);\n *   },\n * );\n * expect(state).toBe(baseState);\n * ```\n */\nfunction rawReturn(value) {\n    if (arguments.length === 0) {\n        throw new Error('rawReturn() must be called with a value.');\n    }\n    if (arguments.length > 1) {\n        throw new Error('rawReturn() must be called with one argument.');\n    }\n    if (value !== undefined &&\n        (typeof value !== 'object' || value === null)) {\n        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');\n    }\n    return {\n        [RAW_RETURN_SYMBOL]: [value],\n    };\n}\n\nconst constructorString = Object.prototype.constructor.toString();\n/**\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\n * support case: https://github.com/unadlib/mutative/issues/17\n */\nconst isSimpleObject = (value) => {\n    if (!value || typeof value !== 'object')\n        return false;\n    const prototype = Object.getPrototypeOf(value);\n    if (prototype === null) {\n        return true;\n    }\n    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') &&\n        prototype.constructor;\n    if (constructor === Object)\n        return true;\n    return (typeof constructor === 'function' &&\n        Function.toString.call(constructor) === constructorString);\n};\nconst markSimpleObject = (value) => {\n    if (isSimpleObject(value)) {\n        return dataTypes.immutable;\n    }\n    return;\n};\n\n/**\n * Cast a value to an Draft type value.\n */\nfunction castDraft(value) {\n    return value;\n}\n/**\n * Cast a value to an Immutable type value.\n */\nfunction castImmutable(value) {\n    return value;\n}\n/**\n * Cast a value to an Mutable type value.\n */\nfunction castMutable(draft) {\n    return draft;\n}\n\n\n//# sourceMappingURL=mutative.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXV0YXRpdmUvZGlzdC9tdXRhdGl2ZS5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVyxJQUFJLGlCQUFpQjtBQUNqRjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0IsbURBQW1EO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGtEQUFrRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQTBEO0FBQzNFO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWtEO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsT0FBTztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EsdUJBQXVCLE9BQU8sWUFBWTtBQUMxQyxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSx1QkFBdUIsT0FBTyxZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsdUJBQXVCLE9BQU8sWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixPQUFPO0FBQ1A7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLFdBQVc7QUFDMUQsOEJBQThCLG9EQUFvRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekMsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGVBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxHQUFHO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsbUJBQW1CLHNCQUFzQjtBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLHVCQUF1QixPQUFPLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBLHVCQUF1QixPQUFPLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUySjtBQUMzSiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxERUxMXFxEb2N1bWVudHNcXGVtYWlsLWNoYXQtaW50ZXJmYWNlXFxub2RlX21vZHVsZXNcXG11dGF0aXZlXFxkaXN0XFxtdXRhdGl2ZS5lc20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE9wZXJhdGlvbiA9IHtcbiAgICBSZW1vdmU6ICdyZW1vdmUnLFxuICAgIFJlcGxhY2U6ICdyZXBsYWNlJyxcbiAgICBBZGQ6ICdhZGQnLFxufTtcblxuLy8gRG9uJ3QgdXNlIGBTeW1ib2woKWAganVzdCBmb3IgM3JkIHBhcnR5IGFjY2VzcyB0aGUgZHJhZnRcbmNvbnN0IFBST1hZX0RSQUZUID0gU3ltYm9sLmZvcignX19NVVRBVElWRV9QUk9YWV9EUkFGVF9fJyk7XG5jb25zdCBSQVdfUkVUVVJOX1NZTUJPTCA9IFN5bWJvbCgnX19NVVRBVElWRV9SQVdfUkVUVVJOX1NZTUJPTF9fJyk7XG5jb25zdCBpdGVyYXRvclN5bWJvbCA9IFN5bWJvbC5pdGVyYXRvcjtcbmNvbnN0IGRhdGFUeXBlcyA9IHtcbiAgICBtdXRhYmxlOiAnbXV0YWJsZScsXG4gICAgaW1tdXRhYmxlOiAnaW1tdXRhYmxlJyxcbn07XG5cbmNvbnN0IGludGVybmFsID0ge307XG5cbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcbiAgICAgICAgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpO1xufVxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwcm90b3R5cGUgPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIHdoaWxlIChwcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIGtleSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHByb3RvdHlwZSA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBpc0Jhc2VTZXRJbnN0YW5jZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IFNldC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBpc0Jhc2VNYXBJbnN0YW5jZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IE1hcC5wcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIGxhdGVzdChwcm94eURyYWZ0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBwcm94eURyYWZ0LmNvcHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHByb3h5RHJhZnQub3JpZ2luYWw7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIGRyYWZ0XG4gKi9cbmZ1bmN0aW9uIGlzRHJhZnQodGFyZ2V0KSB7XG4gICAgcmV0dXJuICEhZ2V0UHJveHlEcmFmdCh0YXJnZXQpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlEcmFmdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlW1BST1hZX0RSQUZUXTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHZhbHVlKTtcbiAgICByZXR1cm4gcHJveHlEcmFmdCA/IChfYSA9IHByb3h5RHJhZnQuY29weSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJveHlEcmFmdC5vcmlnaW5hbCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGRyYWZ0YWJsZVxuICovXG5mdW5jdGlvbiBpc0RyYWZ0YWJsZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBtYXJrUmVzdWx0O1xuICAgIHJldHVybiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fFxuICAgICAgICAoISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcmspICYmXG4gICAgICAgICAgICAoKG1hcmtSZXN1bHQgPSBvcHRpb25zLm1hcmsodmFsdWUsIGRhdGFUeXBlcykpID09PSBkYXRhVHlwZXMuaW1tdXRhYmxlIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIG1hcmtSZXN1bHQgPT09ICdmdW5jdGlvbicpKSk7XG59XG5mdW5jdGlvbiBnZXRQYXRoKHRhcmdldCwgcGF0aCA9IFtdKSB7XG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgJ2tleScpKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwYXJlbnQgaXMgYSBkcmFmdCBhbmQgdGhlIG9yaWdpbmFsIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICBjb25zdCBwYXJlbnRDb3B5ID0gdGFyZ2V0LnBhcmVudC5jb3B5O1xuICAgICAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChnZXQocGFyZW50Q29weSwgdGFyZ2V0LmtleSkpO1xuICAgICAgICBpZiAocHJveHlEcmFmdCAhPT0gbnVsbCAmJiAocHJveHlEcmFmdCA9PT0gbnVsbCB8fCBwcm94eURyYWZ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm94eURyYWZ0Lm9yaWdpbmFsKSAhPT0gdGFyZ2V0Lm9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1NldCA9IHRhcmdldC5wYXJlbnQudHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovO1xuICAgICAgICBjb25zdCBrZXkgPSBpc1NldFxuICAgICAgICAgICAgPyBBcnJheS5mcm9tKHRhcmdldC5wYXJlbnQuc2V0TWFwLmtleXMoKSkuaW5kZXhPZih0YXJnZXQua2V5KVxuICAgICAgICAgICAgOiB0YXJnZXQua2V5O1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGluIHRoZSBuZXh0IHN0YXRlIHBhcmVudFxuICAgICAgICBpZiAoISgoaXNTZXQgJiYgcGFyZW50Q29weS5zaXplID4ga2V5KSB8fCBoYXMocGFyZW50Q29weSwga2V5KSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGlmICh0YXJnZXQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXRoKHRhcmdldC5wYXJlbnQsIHBhdGgpO1xuICAgIH1cbiAgICAvLyBgdGFyZ2V0YCBpcyByb290IGRyYWZ0LlxuICAgIHBhdGgucmV2ZXJzZSgpO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwYXRoIGlzIHZhbGlkXG4gICAgICAgIHJlc29sdmVQYXRoKHRhcmdldC5jb3B5LCBwYXRoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gZ2V0VHlwZSh0YXJnZXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKVxuICAgICAgICByZXR1cm4gMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi87XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgcmV0dXJuIDIgLyogRHJhZnRUeXBlLk1hcCAqLztcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2V0KVxuICAgICAgICByZXR1cm4gMyAvKiBEcmFmdFR5cGUuU2V0ICovO1xuICAgIHJldHVybiAwIC8qIERyYWZ0VHlwZS5PYmplY3QgKi87XG59XG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gZ2V0VHlwZSh0YXJnZXQpID09PSAyIC8qIERyYWZ0VHlwZS5NYXAgKi8gPyB0YXJnZXQuZ2V0KGtleSkgOiB0YXJnZXRba2V5XTtcbn1cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZSh0YXJnZXQpO1xuICAgIGlmICh0eXBlID09PSAyIC8qIERyYWZ0VHlwZS5NYXAgKi8pIHtcbiAgICAgICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcGVlayh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0UHJveHlEcmFmdCh0YXJnZXQpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IHRhcmdldDtcbiAgICByZXR1cm4gc291cmNlW2tleV07XG59XG5mdW5jdGlvbiBpc0VxdWFsKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVByb3h5KHByb3h5RHJhZnQpIHtcbiAgICBpZiAoIXByb3h5RHJhZnQpXG4gICAgICAgIHJldHVybjtcbiAgICB3aGlsZSAocHJveHlEcmFmdC5maW5hbGl0aWVzLnJldm9rZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJldm9rZSA9IHByb3h5RHJhZnQuZmluYWxpdGllcy5yZXZva2UucG9wKCk7XG4gICAgICAgIHJldm9rZSgpO1xuICAgIH1cbn1cbi8vIGhhbmRsZSBKU09OIFBvaW50ZXIgcGF0aCB3aXRoIHNwZWMgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY5MDFcbmZ1bmN0aW9uIGVzY2FwZVBhdGgocGF0aCwgcGF0aEFzQXJyYXkpIHtcbiAgICByZXR1cm4gcGF0aEFzQXJyYXlcbiAgICAgICAgPyBwYXRoXG4gICAgICAgIDogWycnXVxuICAgICAgICAgICAgLmNvbmNhdChwYXRoKVxuICAgICAgICAgICAgLm1hcCgoX2l0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBgJHtfaXRlbX1gO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaW5kZXhPZignLycpID09PSAtMSAmJiBpdGVtLmluZGV4T2YoJ34nKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcvJyk7XG59XG5mdW5jdGlvbiB1bmVzY2FwZVBhdGgocGF0aCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aFxuICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAubWFwKChfaXRlbSkgPT4gX2l0ZW0ucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpKVxuICAgICAgICAuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aChiYXNlLCBwYXRoKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdGgubGVuZ3RoIC0gMTsgaW5kZXggKz0gMSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICAgICAgLy8gdXNlIGBpbmRleGAgaW4gU2V0IGRyYWZ0XG4gICAgICAgIGJhc2UgPSBnZXQoZ2V0VHlwZShiYXNlKSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovID8gQXJyYXkuZnJvbShiYXNlKSA6IGJhc2UsIGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgcGF0Y2ggYXQgJyR7cGF0aC5qb2luKCcvJyl9Jy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0Q29weSh0YXJnZXQpIHtcbiAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSk7XG4gICAgUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICBpZiAoZGVzYy5lbnVtZXJhYmxlICYmIGRlc2MuY29uZmlndXJhYmxlICYmIGRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBmcmVlemVcbiAgICAgICAgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpXG4gICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFtrZXldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIGRlc2MpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xufVxuY29uc3QgcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5mdW5jdGlvbiBzaGFsbG93Q29weShvcmlnaW5hbCwgb3B0aW9ucykge1xuICAgIGxldCBtYXJrUmVzdWx0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5jYWxsKG9yaWdpbmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3JpZ2luYWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgaWYgKCFpc0Jhc2VTZXRJbnN0YW5jZShvcmlnaW5hbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFN1YkNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViQ2xhc3Mob3JpZ2luYWwudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLmRpZmZlcmVuY2VcbiAgICAgICAgICAgID8gU2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlLmNhbGwob3JpZ2luYWwsIG5ldyBTZXQoKSlcbiAgICAgICAgICAgIDogbmV3IFNldChvcmlnaW5hbC52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9yaWdpbmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGlmICghaXNCYXNlTWFwSW5zdGFuY2Uob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICBjb25zdCBTdWJDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YkNsYXNzKG9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcChvcmlnaW5hbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFyaykgJiZcbiAgICAgICAgKChtYXJrUmVzdWx0ID0gb3B0aW9ucy5tYXJrKG9yaWdpbmFsLCBkYXRhVHlwZXMpKSxcbiAgICAgICAgICAgIG1hcmtSZXN1bHQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgbWFya1Jlc3VsdCAhPT0gZGF0YVR5cGVzLm11dGFibGUpIHtcbiAgICAgICAgaWYgKG1hcmtSZXN1bHQgPT09IGRhdGFUeXBlcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3RDb3B5KG9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWFya1Jlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zLmVuYWJsZVBhdGNoZXMgfHwgb3B0aW9ucy5lbmFibGVBdXRvRnJlZXplKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbid0IHVzZSBtYXJrIGFuZCBwYXRjaGVzIG9yIGF1dG8gZnJlZXplIHRvZ2V0aGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1hcmsgcmVzdWx0OiAke21hcmtSZXN1bHR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAvLyBGb3IgYmVzdCBwZXJmb3JtYW5jZSB3aXRoIHNoYWxsb3cgY29waWVzLFxuICAgICAgICAvLyBkb24ndCB1c2UgYE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaiksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikpO2AgYnkgZGVmYXVsdC5cbiAgICAgICAgY29uc3QgY29weSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcmlnaW5hbCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBvcmlnaW5hbFtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvcmlnaW5hbCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcElzRW51bS5jYWxsKG9yaWdpbmFsLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0gb3JpZ2luYWxba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgY2hlY2sgbWFyaygpIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGEgc3RhYmxlIG1hcmtlciBkcmFmdGFibGUgZnVuY3Rpb24uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5jb3B5KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0LmNvcHkgPSBzaGFsbG93Q29weSh0YXJnZXQub3JpZ2luYWwsIHRhcmdldC5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZSh0YXJnZXQpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKHRhcmdldCkpXG4gICAgICAgIHJldHVybiBnZXRWYWx1ZSh0YXJnZXQpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpXG4gICAgICAgIHJldHVybiB0YXJnZXQubWFwKGRlZXBDbG9uZSk7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCBpdGVyYWJsZSA9IEFycmF5LmZyb20odGFyZ2V0LmVudHJpZXMoKSkubWFwKChbaywgdl0pID0+IFtcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBkZWVwQ2xvbmUodiksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIWlzQmFzZU1hcEluc3RhbmNlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFN1YkNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YkNsYXNzKGl0ZXJhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcChpdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgaXRlcmFibGUgPSBBcnJheS5mcm9tKHRhcmdldCkubWFwKGRlZXBDbG9uZSk7XG4gICAgICAgIGlmICghaXNCYXNlU2V0SW5zdGFuY2UodGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc3QgU3ViQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViQ2xhc3MoaXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2V0KGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldClcbiAgICAgICAgY29weVtrZXldID0gZGVlcENsb25lKHRhcmdldFtrZXldKTtcbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGNsb25lSWZOZWVkZWQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzRHJhZnQodGFyZ2V0KSA/IGRlZXBDbG9uZSh0YXJnZXQpIDogdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlZChwcm94eURyYWZ0KSB7XG4gICAgdmFyIF9hO1xuICAgIHByb3h5RHJhZnQuYXNzaWduZWRNYXAgPSAoX2EgPSBwcm94eURyYWZ0LmFzc2lnbmVkTWFwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgTWFwKCk7XG4gICAgaWYgKCFwcm94eURyYWZ0Lm9wZXJhdGVkKSB7XG4gICAgICAgIHByb3h5RHJhZnQub3BlcmF0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAocHJveHlEcmFmdC5wYXJlbnQpIHtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHByb3h5RHJhZnQucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dGcm96ZW5FcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgZnJvemVuIG9iamVjdCcpO1xufVxuZnVuY3Rpb24gZGVlcEZyZWV6ZSh0YXJnZXQsIHN1YktleSwgdXBkYXRlZFZhbHVlcywgc3RhY2ssIGtleXMpIHtcbiAgICB7XG4gICAgICAgIHVwZGF0ZWRWYWx1ZXMgPSB1cGRhdGVkVmFsdWVzICE9PSBudWxsICYmIHVwZGF0ZWRWYWx1ZXMgIT09IHZvaWQgMCA/IHVwZGF0ZWRWYWx1ZXMgOiBuZXcgV2Vha01hcCgpO1xuICAgICAgICBzdGFjayA9IHN0YWNrICE9PSBudWxsICYmIHN0YWNrICE9PSB2b2lkIDAgPyBzdGFjayA6IFtdO1xuICAgICAgICBrZXlzID0ga2V5cyAhPT0gbnVsbCAmJiBrZXlzICE9PSB2b2lkIDAgPyBrZXlzIDogW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlZFZhbHVlcy5oYXModGFyZ2V0KVxuICAgICAgICAgICAgPyB1cGRhdGVkVmFsdWVzLmdldCh0YXJnZXQpXG4gICAgICAgICAgICA6IHRhcmdldDtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3RhY2suaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZTogfi8ke2tleXNcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChrZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgWyR7a2V5LnRvU3RyaW5nKCl9XWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHN0YWNrW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFyZW50IGluc3RhbmNlb2YgTWFwIHx8IHBhcmVudCBpbnN0YW5jZW9mIFNldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQua2V5cygpKS5pbmRleE9mKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJy8nKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAga2V5cy5wdXNoKHN1YktleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LmlzRnJvemVuKHRhcmdldCkgfHwgaXNEcmFmdCh0YXJnZXQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAga2V5cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHRhcmdldCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMiAvKiBEcmFmdFR5cGUuTWFwICovOlxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZGVlcEZyZWV6ZShrZXksIGtleSwgdXBkYXRlZFZhbHVlcywgc3RhY2ssIGtleXMpO1xuICAgICAgICAgICAgICAgIGRlZXBGcmVlemUodmFsdWUsIGtleSwgdXBkYXRlZFZhbHVlcywgc3RhY2ssIGtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnNldCA9IHRhcmdldC5jbGVhciA9IHRhcmdldC5kZWxldGUgPSB0aHJvd0Zyb3plbkVycm9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBEcmFmdFR5cGUuU2V0ICovOlxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkZWVwRnJlZXplKHZhbHVlLCB2YWx1ZSwgdXBkYXRlZFZhbHVlcywgc3RhY2ssIGtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LmFkZCA9IHRhcmdldC5jbGVhciA9IHRhcmdldC5kZWxldGUgPSB0aHJvd0Zyb3plbkVycm9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi86XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRhcmdldCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkZWVwRnJlZXplKHZhbHVlLCBpbmRleCwgdXBkYXRlZFZhbHVlcywgc3RhY2ssIGtleXMpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBub24tZW51bWVyYWJsZSBvciBzeW1ib2wgcHJvcGVydGllc1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSwgbmFtZSwgdXBkYXRlZFZhbHVlcywgc3RhY2ssIGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGtleXMucG9wKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHRhcmdldCwgaXRlcikge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHRhcmdldCk7XG4gICAgaWYgKHR5cGUgPT09IDAgLyogRHJhZnRUeXBlLk9iamVjdCAqLykge1xuICAgICAgICBSZWZsZWN0Lm93bktleXModGFyZ2V0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGl0ZXIoa2V5LCB0YXJnZXRba2V5XSwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IDEgLyogRHJhZnRUeXBlLkFycmF5ICovKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpdGVyKGluZGV4LCBlbnRyeSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldC5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IGl0ZXIoaW5kZXgsIGVudHJ5LCB0YXJnZXQpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVZhbHVlKHRhcmdldCwgaGFuZGxlZFNldCwgb3B0aW9ucykge1xuICAgIGlmIChpc0RyYWZ0KHRhcmdldCkgfHxcbiAgICAgICAgIWlzRHJhZnRhYmxlKHRhcmdldCwgb3B0aW9ucykgfHxcbiAgICAgICAgaGFuZGxlZFNldC5oYXModGFyZ2V0KSB8fFxuICAgICAgICBPYmplY3QuaXNGcm96ZW4odGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzU2V0ID0gdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xuICAgIGNvbnN0IHNldE1hcCA9IGlzU2V0ID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICAgIGhhbmRsZWRTZXQuYWRkKHRhcmdldCk7XG4gICAgZm9yRWFjaCh0YXJnZXQsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGlzRHJhZnQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdCh2YWx1ZSk7XG4gICAgICAgICAgICBlbnN1cmVTaGFsbG93Q29weShwcm94eURyYWZ0KTtcbiAgICAgICAgICAgIC8vIEEgZHJhZnQgd2hlcmUgYSBjaGlsZCBub2RlIGhhcyBiZWVuIGNoYW5nZWQsIG9yIGFzc2lnbmVkIGEgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZSA9ICgoX2EgPSBwcm94eURyYWZ0LmFzc2lnbmVkTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgfHwgcHJveHlEcmFmdC5vcGVyYXRlZFxuICAgICAgICAgICAgICAgID8gcHJveHlEcmFmdC5jb3B5XG4gICAgICAgICAgICAgICAgOiBwcm94eURyYWZ0Lm9yaWdpbmFsO1xuICAgICAgICAgICAgLy8gZmluYWwgdXBkYXRlIHZhbHVlXG4gICAgICAgICAgICBzZXQoaXNTZXQgPyBzZXRNYXAgOiB0YXJnZXQsIGtleSwgdXBkYXRlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVZhbHVlKHZhbHVlLCBoYW5kbGVkU2V0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzZXRNYXApIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gdGFyZ2V0O1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgIHNldC5jbGVhcigpO1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHNldC5hZGQoc2V0TWFwLmhhcyh2YWx1ZSkgPyBzZXRNYXAuZ2V0KHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluYWxpemVBc3NpZ25lZChwcm94eURyYWZ0LCBrZXkpIHtcbiAgICAvLyBoYW5kbGUgdGhlIGRyYWZ0YWJsZSBhc3NpZ25lZCB2YWx1ZXPvvIwgYW5kIHRoZSB2YWx1ZSBpcyBub3QgYSBkcmFmdFxuICAgIGNvbnN0IGNvcHkgPSBwcm94eURyYWZ0LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyA/IHByb3h5RHJhZnQuc2V0TWFwIDogcHJveHlEcmFmdC5jb3B5O1xuICAgIGlmIChwcm94eURyYWZ0LmZpbmFsaXRpZXMucmV2b2tlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgcHJveHlEcmFmdC5hc3NpZ25lZE1hcC5nZXQoa2V5KSAmJlxuICAgICAgICBjb3B5KSB7XG4gICAgICAgIGhhbmRsZVZhbHVlKGdldChjb3B5LCBrZXkpLCBwcm94eURyYWZ0LmZpbmFsaXRpZXMuaGFuZGxlZFNldCwgcHJveHlEcmFmdC5vcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVNldFZhbHVlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQudHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovICYmIHRhcmdldC5jb3B5KSB7XG4gICAgICAgIHRhcmdldC5jb3B5LmNsZWFyKCk7XG4gICAgICAgIHRhcmdldC5zZXRNYXAuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5jb3B5LmFkZChnZXRWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVBhdGNoZXModGFyZ2V0LCBnZW5lcmF0ZVBhdGNoZXMsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgY29uc3Qgc2hvdWxkRmluYWxpemUgPSB0YXJnZXQub3BlcmF0ZWQgJiZcbiAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwICYmXG4gICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zaXplID4gMCAmJlxuICAgICAgICAhdGFyZ2V0LmZpbmFsaXplZDtcbiAgICBpZiAoc2hvdWxkRmluYWxpemUpIHtcbiAgICAgICAgaWYgKHBhdGNoZXMgJiYgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gZ2V0UGF0aCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGJhc2VQYXRoKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVQYXRjaGVzKHRhcmdldCwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrRmluYWxpemF0aW9uKHRhcmdldCwga2V5LCB2YWx1ZSwgZ2VuZXJhdGVQYXRjaGVzKSB7XG4gICAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodmFsdWUpO1xuICAgIGlmIChwcm94eURyYWZ0KSB7XG4gICAgICAgIC8vICFjYXNlOiBhc3NpZ24gdGhlIGRyYWZ0IHZhbHVlXG4gICAgICAgIGlmICghcHJveHlEcmFmdC5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHByb3h5RHJhZnQuY2FsbGJhY2tzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcHJveHlEcmFmdC5jYWxsYmFja3MucHVzaCgocGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSB0YXJnZXQudHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovID8gdGFyZ2V0LnNldE1hcCA6IHRhcmdldC5jb3B5O1xuICAgICAgICAgICAgaWYgKGlzRXF1YWwoZ2V0KGNvcHksIGtleSksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkVmFsdWUgPSBwcm94eURyYWZ0Lm9yaWdpbmFsO1xuICAgICAgICAgICAgICAgIGlmIChwcm94eURyYWZ0LmNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFZhbHVlID0gcHJveHlEcmFmdC5jb3B5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVNldFZhbHVlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZmluYWxpemVQYXRjaGVzKHRhcmdldCwgZ2VuZXJhdGVQYXRjaGVzLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLmVuYWJsZUF1dG9GcmVlemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm9wdGlvbnMudXBkYXRlZFZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0YXJnZXQub3B0aW9ucy51cGRhdGVkVmFsdWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQub3B0aW9ucy51cGRhdGVkVmFsdWVzLnNldCh1cGRhdGVkVmFsdWUsIHByb3h5RHJhZnQub3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaW5hbCB1cGRhdGUgdmFsdWVcbiAgICAgICAgICAgICAgICBzZXQoY29weSwga2V5LCB1cGRhdGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLmVuYWJsZUF1dG9GcmVlemUpIHtcbiAgICAgICAgICAgIC8vICFjYXNlOiBhc3NpZ24gdGhlIGRyYWZ0IHZhbHVlIGluIGNyb3NzIGRyYWZ0IHRyZWVcbiAgICAgICAgICAgIGlmIChwcm94eURyYWZ0LmZpbmFsaXRpZXMgIT09IHRhcmdldC5maW5hbGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm9wdGlvbnMuZW5hYmxlQXV0b0ZyZWV6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSwgdGFyZ2V0Lm9wdGlvbnMpKSB7XG4gICAgICAgIC8vICFjYXNlOiBhc3NpZ24gdGhlIG5vbi1kcmFmdCB2YWx1ZVxuICAgICAgICB0YXJnZXQuZmluYWxpdGllcy5kcmFmdC5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSB0YXJnZXQudHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovID8gdGFyZ2V0LnNldE1hcCA6IHRhcmdldC5jb3B5O1xuICAgICAgICAgICAgaWYgKGlzRXF1YWwoZ2V0KGNvcHksIGtleSksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpbmFsaXplQXNzaWduZWQodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHByb3h5U3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcywgcGF0aEFzQXJyYXkpIHtcbiAgICBsZXQgeyBvcmlnaW5hbCwgYXNzaWduZWRNYXAsIG9wdGlvbnMgfSA9IHByb3h5U3RhdGU7XG4gICAgbGV0IGNvcHkgPSBwcm94eVN0YXRlLmNvcHk7XG4gICAgaWYgKGNvcHkubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIFtvcmlnaW5hbCwgY29weV0gPSBbY29weSwgb3JpZ2luYWxdO1xuICAgICAgICBbcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG9yaWdpbmFsLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoYXNzaWduZWRNYXAuZ2V0KGluZGV4LnRvU3RyaW5nKCkpICYmIGNvcHlbaW5kZXhdICE9PSBvcmlnaW5hbFtpbmRleF0pIHtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFtpbmRleF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVzY2FwZVBhdGgoX3BhdGgsIHBhdGhBc0FycmF5KTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5SZXBsYWNlLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBkcmFmdCwgaXQgbmVlZHMgdG8gYmUgZGVlcCBjbG9uZWQsIGFuZCBpdCBtYXkgYWxzbyBiZSBub24tZHJhZnQuXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lSWZOZWVkZWQoY29weVtpbmRleF0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogT3BlcmF0aW9uLlJlcGxhY2UsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBhIGRyYWZ0LCBpdCBuZWVkcyB0byBiZSBkZWVwIGNsb25lZCwgYW5kIGl0IG1heSBhbHNvIGJlIG5vbi1kcmFmdC5cbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xvbmVJZk5lZWRlZChvcmlnaW5hbFtpbmRleF0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSBvcmlnaW5hbC5sZW5ndGg7IGluZGV4IDwgY29weS5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY29uc3QgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoW2luZGV4XSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBlc2NhcGVQYXRoKF9wYXRoLCBwYXRoQXNBcnJheSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICBvcDogT3BlcmF0aW9uLkFkZCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIGRyYWZ0LCBpdCBuZWVkcyB0byBiZSBkZWVwIGNsb25lZCwgYW5kIGl0IG1heSBhbHNvIGJlIG5vbi1kcmFmdC5cbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZUlmTmVlZGVkKGNvcHlbaW5kZXhdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbC5sZW5ndGggPCBjb3B5Lmxlbmd0aCkge1xuICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjkwMiNhcHBlbmRpeC1BLjRcbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlLCBoZXJlIHdlIG9ubHkgZ2VuZXJhdGUgYW4gb3BlcmF0aW9uIHRoYXQgcmVwbGFjZXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksXG4gICAgICAgIC8vIHdoaWNoIGlzIGluY29uc2lzdGVudCB3aXRoIEpTT04gUGF0Y2ggc3BlY2lmaWNhdGlvblxuICAgICAgICBjb25zdCB7IGFycmF5TGVuZ3RoQXNzaWdubWVudCA9IHRydWUgfSA9IG9wdGlvbnMuZW5hYmxlUGF0Y2hlcztcbiAgICAgICAgaWYgKGFycmF5TGVuZ3RoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoWydsZW5ndGgnXSk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZXNjYXBlUGF0aChfcGF0aCwgcGF0aEFzQXJyYXkpO1xuICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5SZXBsYWNlLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSBjb3B5Lmxlbmd0aDsgb3JpZ2luYWwubGVuZ3RoIDwgaW5kZXg7IGluZGV4IC09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVzY2FwZVBhdGgoX3BhdGgsIHBhdGhBc0FycmF5KTtcbiAgICAgICAgICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoeyBvcmlnaW5hbCwgY29weSwgYXNzaWduZWRNYXAgfSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBwYXRoQXNBcnJheSkge1xuICAgIGFzc2lnbmVkTWFwLmZvckVhY2goKGFzc2lnbmVkVmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gZ2V0KG9yaWdpbmFsLCBrZXkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNsb25lSWZOZWVkZWQoZ2V0KGNvcHksIGtleSkpO1xuICAgICAgICBjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlXG4gICAgICAgICAgICA/IE9wZXJhdGlvbi5SZW1vdmVcbiAgICAgICAgICAgIDogaGFzKG9yaWdpbmFsLCBrZXkpXG4gICAgICAgICAgICAgICAgPyBPcGVyYXRpb24uUmVwbGFjZVxuICAgICAgICAgICAgICAgIDogT3BlcmF0aW9uLkFkZDtcbiAgICAgICAgaWYgKGlzRXF1YWwob3JpZ2luYWxWYWx1ZSwgdmFsdWUpICYmIG9wID09PSBPcGVyYXRpb24uUmVwbGFjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5KTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGVzY2FwZVBhdGgoX3BhdGgsIHBhdGhBc0FycmF5KTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKG9wID09PSBPcGVyYXRpb24uUmVtb3ZlID8geyBvcCwgcGF0aCB9IDogeyBvcCwgcGF0aCwgdmFsdWUgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnB1c2gob3AgPT09IE9wZXJhdGlvbi5BZGRcbiAgICAgICAgICAgID8geyBvcDogT3BlcmF0aW9uLlJlbW92ZSwgcGF0aCB9XG4gICAgICAgICAgICA6IG9wID09PSBPcGVyYXRpb24uUmVtb3ZlXG4gICAgICAgICAgICAgICAgPyB7IG9wOiBPcGVyYXRpb24uQWRkLCBwYXRoLCB2YWx1ZTogb3JpZ2luYWxWYWx1ZSB9XG4gICAgICAgICAgICAgICAgOiB7IG9wOiBPcGVyYXRpb24uUmVwbGFjZSwgcGF0aCwgdmFsdWU6IG9yaWdpbmFsVmFsdWUgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoeyBvcmlnaW5hbCwgY29weSB9LCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMsIHBhdGhBc0FycmF5KSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBvcmlnaW5hbC5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIWNvcHkuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoW2luZGV4XSk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZXNjYXBlUGF0aChfcGF0aCwgcGF0aEFzQXJyYXkpO1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogT3BlcmF0aW9uLlJlbW92ZSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICBvcDogT3BlcmF0aW9uLkFkZCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICB9KTtcbiAgICBpbmRleCA9IDA7XG4gICAgY29weS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIW9yaWdpbmFsLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFtpbmRleF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVzY2FwZVBhdGgoX3BhdGgsIHBhdGhBc0FycmF5KTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5BZGQsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5SZW1vdmUsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXMocHJveHlTdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgY29uc3QgeyBwYXRoQXNBcnJheSA9IHRydWUgfSA9IHByb3h5U3RhdGUub3B0aW9ucy5lbmFibGVQYXRjaGVzO1xuICAgIHN3aXRjaCAocHJveHlTdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBEcmFmdFR5cGUuT2JqZWN0ICovOlxuICAgICAgICBjYXNlIDIgLyogRHJhZnRUeXBlLk1hcCAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQocHJveHlTdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBwYXRoQXNBcnJheSk7XG4gICAgICAgIGNhc2UgMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi86XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMocHJveHlTdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBwYXRoQXNBcnJheSk7XG4gICAgICAgIGNhc2UgMyAvKiBEcmFmdFR5cGUuU2V0ICovOlxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhwcm94eVN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMsIHBhdGhBc0FycmF5KTtcbiAgICB9XG59XG5cbmxldCByZWFkYWJsZSA9IGZhbHNlO1xuY29uc3QgY2hlY2tSZWFkYWJsZSA9ICh2YWx1ZSwgb3B0aW9ucywgaWdub3JlQ2hlY2tEcmFmdGFibGUgPSBmYWxzZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICghaXNEcmFmdGFibGUodmFsdWUsIG9wdGlvbnMpIHx8IGlnbm9yZUNoZWNrRHJhZnRhYmxlKSAmJlxuICAgICAgICAhcmVhZGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpY3QgbW9kZTogTXV0YWJsZSBkYXRhIGNhbm5vdCBiZSBhY2Nlc3NlZCBkaXJlY3RseSwgcGxlYXNlIHVzZSAndW5zYWZlKGNhbGxiYWNrKScgd3JhcC5gKTtcbiAgICB9XG59O1xuLyoqXG4gKiBgdW5zYWZlKGNhbGxiYWNrKWAgdG8gYWNjZXNzIG11dGFibGUgZGF0YSBkaXJlY3RseSBpbiBzdHJpY3QgbW9kZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZSwgdW5zYWZlIH0gZnJvbSAnLi4vaW5kZXgnO1xuICpcbiAqIGNsYXNzIEZvb2JhciB7XG4gKiAgIGJhciA9IDE7XG4gKiB9XG4gKlxuICogY29uc3QgYmFzZVN0YXRlID0geyBmb29iYXI6IG5ldyBGb29iYXIoKSB9O1xuICogY29uc3Qgc3RhdGUgPSBjcmVhdGUoXG4gKiAgIGJhc2VTdGF0ZSxcbiAqICAgKGRyYWZ0KSA9PiB7XG4gKiAgICB1bnNhZmUoKCkgPT4ge1xuICogICAgICBkcmFmdC5mb29iYXIuYmFyID0gMjtcbiAqICAgIH0pO1xuICogICB9LFxuICogICB7XG4gKiAgICAgc3RyaWN0OiB0cnVlLFxuICogICB9XG4gKiApO1xuICpcbiAqIGV4cGVjdChzdGF0ZSkudG9CZShiYXNlU3RhdGUpO1xuICogZXhwZWN0KHN0YXRlLmZvb2JhcikudG9CZShiYXNlU3RhdGUuZm9vYmFyKTtcbiAqIGV4cGVjdChzdGF0ZS5mb29iYXIuYmFyKS50b0JlKDIpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZShjYWxsYmFjaykge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBtYXBIYW5kbGVyID0ge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gbGF0ZXN0KGdldFByb3h5RHJhZnQodGhpcykpO1xuICAgICAgICByZXR1cm4gY3VycmVudC5zaXplO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gbGF0ZXN0KGdldFByb3h5RHJhZnQodGhpcykpLmhhcyhrZXkpO1xuICAgIH0sXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbGF0ZXN0KHRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlLmhhcyhrZXkpIHx8ICFpc0VxdWFsKHNvdXJjZS5nZXQoa2V5KSwgdmFsdWUpKSB7XG4gICAgICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIHRhcmdldC5jb3B5LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIG1hcmtGaW5hbGl6YXRpb24odGFyZ2V0LCBrZXksIHZhbHVlLCBnZW5lcmF0ZVBhdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICBtYXJrQ2hhbmdlZCh0YXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0Lm9yaWdpbmFsLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5jb3B5LmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgbWFya0NoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRhcmdldC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuY29weS5jbGVhcigpO1xuICAgIH0sXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBsYXRlc3QodGFyZ2V0KS5mb3JFYWNoKChfdmFsdWUsIF9rZXkpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoX2tleSksIF9rZXksIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGdldChrZXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3QodGFyZ2V0KS5nZXQoa2V5KTtcbiAgICAgICAgY29uc3QgbXV0YWJsZSA9ICgoX2IgPSAoX2EgPSB0YXJnZXQub3B0aW9ucykubWFyaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHZhbHVlLCBkYXRhVHlwZXMpKSA9PT0gZGF0YVR5cGVzLm11dGFibGU7XG4gICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgIGNoZWNrUmVhZGFibGUodmFsdWUsIHRhcmdldC5vcHRpb25zLCBtdXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXV0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuZmluYWxpemVkIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSwgdGFyZ2V0Lm9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHJhZnRlZCBvciByZWFzc2lnbmVkXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGFyZ2V0Lm9yaWdpbmFsLmdldChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJhZnQgPSBpbnRlcm5hbC5jcmVhdGVEcmFmdCh7XG4gICAgICAgICAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgICAgICAgICBwYXJlbnREcmFmdDogdGFyZ2V0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZmluYWxpdGllczogdGFyZ2V0LmZpbmFsaXRpZXMsXG4gICAgICAgICAgICBvcHRpb25zOiB0YXJnZXQub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KHRhcmdldCk7XG4gICAgICAgIHRhcmdldC5jb3B5LnNldChrZXksIGRyYWZ0KTtcbiAgICAgICAgcmV0dXJuIGRyYWZ0O1xuICAgIH0sXG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIGxhdGVzdChnZXRQcm94eURyYWZ0KHRoaXMpKS5rZXlzKCk7XG4gICAgfSxcbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbaXRlcmF0b3JTeW1ib2xdOiAoKSA9PiB0aGlzLnZhbHVlcygpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbaXRlcmF0b3JTeW1ib2xdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtyZXN1bHQudmFsdWUsIHZhbHVlXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFtpdGVyYXRvclN5bWJvbF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9LFxufTtcbmNvbnN0IG1hcEhhbmRsZXJLZXlzID0gUmVmbGVjdC5vd25LZXlzKG1hcEhhbmRsZXIpO1xuXG5jb25zdCBnZXROZXh0SXRlcmF0b3IgPSAodGFyZ2V0LCBpdGVyYXRvciwgeyBpc1ZhbHVlc0l0ZXJhdG9yIH0pID0+ICgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3Qga2V5ID0gcmVzdWx0LnZhbHVlO1xuICAgIGxldCB2YWx1ZSA9IHRhcmdldC5zZXRNYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgY3VycmVudERyYWZ0ID0gZ2V0UHJveHlEcmFmdCh2YWx1ZSk7XG4gICAgY29uc3QgbXV0YWJsZSA9ICgoX2IgPSAoX2EgPSB0YXJnZXQub3B0aW9ucykubWFyaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHZhbHVlLCBkYXRhVHlwZXMpKSA9PT0gZGF0YVR5cGVzLm11dGFibGU7XG4gICAgaWYgKHRhcmdldC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICBjaGVja1JlYWRhYmxlKGtleSwgdGFyZ2V0Lm9wdGlvbnMsIG11dGFibGUpO1xuICAgIH1cbiAgICBpZiAoIW11dGFibGUgJiZcbiAgICAgICAgIWN1cnJlbnREcmFmdCAmJlxuICAgICAgICBpc0RyYWZ0YWJsZShrZXksIHRhcmdldC5vcHRpb25zKSAmJlxuICAgICAgICAhdGFyZ2V0LmZpbmFsaXplZCAmJlxuICAgICAgICB0YXJnZXQub3JpZ2luYWwuaGFzKGtleSkpIHtcbiAgICAgICAgLy8gZHJhZnQgYSBkcmFmdGFibGUgb3JpZ2luYWwgc2V0IGl0ZW1cbiAgICAgICAgY29uc3QgcHJveHkgPSBpbnRlcm5hbC5jcmVhdGVEcmFmdCh7XG4gICAgICAgICAgICBvcmlnaW5hbDoga2V5LFxuICAgICAgICAgICAgcGFyZW50RHJhZnQ6IHRhcmdldCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGZpbmFsaXRpZXM6IHRhcmdldC5maW5hbGl0aWVzLFxuICAgICAgICAgICAgb3B0aW9uczogdGFyZ2V0Lm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0YXJnZXQuc2V0TWFwLnNldChrZXksIHByb3h5KTtcbiAgICAgICAgdmFsdWUgPSBwcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVudERyYWZ0KSB7XG4gICAgICAgIC8vIGRyYWZ0ZWRcbiAgICAgICAgdmFsdWUgPSBjdXJyZW50RHJhZnQucHJveHk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogaXNWYWx1ZXNJdGVyYXRvciA/IHZhbHVlIDogW3ZhbHVlLCB2YWx1ZV0sXG4gICAgfTtcbn07XG5jb25zdCBzZXRIYW5kbGVyID0ge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnNldE1hcC5zaXplO1xuICAgIH0sXG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQodGhpcyk7XG4gICAgICAgIC8vIHJlYXNzaWduZWQgb3Igbm9uLWRyYWZ0YWJsZSB2YWx1ZXNcbiAgICAgICAgaWYgKHRhcmdldC5zZXRNYXAuaGFzKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICBjb25zdCB2YWx1ZVByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHZhbHVlKTtcbiAgICAgICAgLy8gZHJhZnRlZFxuICAgICAgICBpZiAodmFsdWVQcm94eURyYWZ0ICYmIHRhcmdldC5zZXRNYXAuaGFzKHZhbHVlUHJveHlEcmFmdC5vcmlnaW5hbCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQodmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgdGFyZ2V0LnNldE1hcC5zZXQodmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIG1hcmtGaW5hbGl6YXRpb24odGFyZ2V0LCB2YWx1ZSwgdmFsdWUsIGdlbmVyYXRlUGF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWxldGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICBtYXJrQ2hhbmdlZCh0YXJnZXQpO1xuICAgICAgICBjb25zdCB2YWx1ZVByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlUHJveHlEcmFmdCAmJiB0YXJnZXQuc2V0TWFwLmhhcyh2YWx1ZVByb3h5RHJhZnQub3JpZ2luYWwpKSB7XG4gICAgICAgICAgICAvLyBkZWxldGUgZHJhZnRlZFxuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLnNldCh2YWx1ZVByb3h5RHJhZnQub3JpZ2luYWwsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2V0TWFwLmRlbGV0ZSh2YWx1ZVByb3h5RHJhZnQub3JpZ2luYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVQcm94eURyYWZ0ICYmIHRhcmdldC5zZXRNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gbm9uLWRyYWZ0YWJsZSB2YWx1ZXNcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlYXNzaWduZWRcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5kZWxldGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlbGV0ZSByZWFzc2lnbmVkIG9yIG5vbi1kcmFmdGFibGUgdmFsdWVzXG4gICAgICAgIHJldHVybiB0YXJnZXQuc2V0TWFwLmRlbGV0ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQodGhpcyk7XG4gICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KHRhcmdldCk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHRhcmdldCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGFyZ2V0Lm9yaWdpbmFsKSB7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnNldE1hcC5jbGVhcigpO1xuICAgIH0sXG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRhcmdldC5zZXRNYXAua2V5cygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMudmFsdWVzKCksXG4gICAgICAgICAgICBuZXh0OiBnZXROZXh0SXRlcmF0b3IodGFyZ2V0LCBpdGVyYXRvciwgeyBpc1ZhbHVlc0l0ZXJhdG9yOiB0cnVlIH0pLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0YXJnZXQuc2V0TWFwLmtleXMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgICAgIG5leHQ6IGdldE5leHRJdGVyYXRvcih0YXJnZXQsIGl0ZXJhdG9yLCB7XG4gICAgICAgICAgICAgICAgaXNWYWx1ZXNJdGVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH0sXG4gICAgW2l0ZXJhdG9yU3ltYm9sXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfSxcbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmlmIChTZXQucHJvdG90eXBlLmRpZmZlcmVuY2UpIHtcbiAgICAvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5ldyBTZXQgbWV0aG9kc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNldC1tZXRob2RzXG4gICAgLy8gQW5kIGBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zZXQtbWV0aG9kcy9ibG9iL21haW4vZGV0YWlscy5tZCNzeW1ib2xzcGVjaWVzYCBoYXMgc29tZSBkZXRhaWxzIGFib3V0IHRoZSBgQEBzcGVjaWVzYCBzeW1ib2wuXG4gICAgLy8gU28gd2UgY2FuJ3QgdXNlIFN1YlNldCBpbnN0YW5jZSBjb25zdHJ1Y3RvciB0byBnZXQgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTdWJTZXQgaW5zdGFuY2UuXG4gICAgT2JqZWN0LmFzc2lnbihzZXRIYW5kbGVyLCB7XG4gICAgICAgIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgICAgICB1bmlvbihvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIFNldC5wcm90b3R5cGUudW5pb24uY2FsbChuZXcgU2V0KHRoaXMudmFsdWVzKCkpLCBvdGhlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRpZmZlcmVuY2Uob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLmRpZmZlcmVuY2UuY2FsbChuZXcgU2V0KHRoaXMudmFsdWVzKCkpLCBvdGhlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLnN5bW1ldHJpY0RpZmZlcmVuY2UuY2FsbChuZXcgU2V0KHRoaXMudmFsdWVzKCkpLCBvdGhlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3Vic2V0T2Yob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLmlzU3Vic2V0T2YuY2FsbChuZXcgU2V0KHRoaXMudmFsdWVzKCkpLCBvdGhlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3VwZXJzZXRPZihvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIFNldC5wcm90b3R5cGUuaXNTdXBlcnNldE9mLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgICAgICBpc0Rpc2pvaW50RnJvbShvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIFNldC5wcm90b3R5cGUuaXNEaXNqb2ludEZyb20uY2FsbChuZXcgU2V0KHRoaXMudmFsdWVzKCkpLCBvdGhlcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5jb25zdCBzZXRIYW5kbGVyS2V5cyA9IFJlZmxlY3Qub3duS2V5cyhzZXRIYW5kbGVyKTtcblxuY29uc3QgZHJhZnRzQ2FjaGUgPSBuZXcgV2Vha1NldCgpO1xuY29uc3QgcHJveHlIYW5kbGVyID0ge1xuICAgIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY29weSA9IChfYSA9IHRhcmdldC5jb3B5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fba2V5XTtcbiAgICAgICAgLy8gSW1wcm92ZSBkcmFmdCByZWFkaW5nIHBlcmZvcm1hbmNlIGJ5IGNhY2hpbmcgdGhlIGRyYWZ0IGNvcHkuXG4gICAgICAgIGlmIChjb3B5ICYmIGRyYWZ0c0NhY2hlLmhhcyhjb3B5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gUFJPWFlfRFJBRlQpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICBsZXQgbWFya1Jlc3VsdDtcbiAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLm1hcmspIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBgVW5jYXVnaHQgVHlwZUVycm9yOiBNZXRob2QgZ2V0IE1hcC5wcm90b3R5cGUuc2l6ZSBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyICM8TWFwPmBcbiAgICAgICAgICAgIC8vIG9yIGBVbmNhdWdodCBUeXBlRXJyb3I6IE1ldGhvZCBnZXQgU2V0LnByb3RvdHlwZS5zaXplIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXIgIzxTZXQ+YFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBrZXkgPT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICh0YXJnZXQub3JpZ2luYWwgaW5zdGFuY2VvZiBNYXAgfHwgdGFyZ2V0Lm9yaWdpbmFsIGluc3RhbmNlb2YgU2V0KVxuICAgICAgICAgICAgICAgID8gUmVmbGVjdC5nZXQodGFyZ2V0Lm9yaWdpbmFsLCBrZXkpXG4gICAgICAgICAgICAgICAgOiBSZWZsZWN0LmdldCh0YXJnZXQub3JpZ2luYWwsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgbWFya1Jlc3VsdCA9IHRhcmdldC5vcHRpb25zLm1hcmsodmFsdWUsIGRhdGFUeXBlcyk7XG4gICAgICAgICAgICBpZiAobWFya1Jlc3VsdCA9PT0gZGF0YVR5cGVzLm11dGFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUmVhZGFibGUodmFsdWUsIHRhcmdldC5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGxhdGVzdCh0YXJnZXQpO1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgTWFwICYmIG1hcEhhbmRsZXJLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaXplJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1hcEhhbmRsZXIsICdzaXplJykuZ2V0LmNhbGwodGFyZ2V0LnByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IG1hcEhhbmRsZXJba2V5XTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLmJpbmQodGFyZ2V0LnByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgU2V0ICYmIHNldEhhbmRsZXJLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaXplJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNldEhhbmRsZXIsICdzaXplJykuZ2V0LmNhbGwodGFyZ2V0LnByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldEhhbmRsZXJba2V5XTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLmJpbmQodGFyZ2V0LnByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhcyhzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjXG4gICAgICAgICAgICAgICAgPyBgdmFsdWVgIGluIGRlc2NcbiAgICAgICAgICAgICAgICAgICAgPyBkZXNjLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogLy8gIWNhc2U6IHN1cHBvcnQgZm9yIGdldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gZGVzYy5nZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRhcmdldC5wcm94eSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBpZiAodGFyZ2V0Lm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICBjaGVja1JlYWRhYmxlKHZhbHVlLCB0YXJnZXQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5maW5hbGl6ZWQgfHwgIWlzRHJhZnRhYmxlKHZhbHVlLCB0YXJnZXQub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYXNzaWduZWQgdmFsdWVzIGFyZSBub3QgZHJhZnRlZFxuICAgICAgICBpZiAodmFsdWUgPT09IHBlZWsodGFyZ2V0Lm9yaWdpbmFsLCBrZXkpKSB7XG4gICAgICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICAgICAgdGFyZ2V0LmNvcHlba2V5XSA9IGNyZWF0ZURyYWZ0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbDogdGFyZ2V0Lm9yaWdpbmFsW2tleV0sXG4gICAgICAgICAgICAgICAgcGFyZW50RHJhZnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBrZXk6IHRhcmdldC50eXBlID09PSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLyA/IE51bWJlcihrZXkpIDoga2V5LFxuICAgICAgICAgICAgICAgIGZpbmFsaXRpZXM6IHRhcmdldC5maW5hbGl0aWVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRhcmdldC5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAhY2FzZTogc3VwcG9ydCBmb3IgY3VzdG9tIHNoYWxsb3cgY29weSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXJrUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViUHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodGFyZ2V0LmNvcHlba2V5XSk7XG4gICAgICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkoc3ViUHJveHlEcmFmdCk7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhIGN1c3RvbSBzaGFsbG93IGNvcHkgdG8gdXBkYXRlIHRvIGEgbmV3IGNvcHlcbiAgICAgICAgICAgICAgICBtYXJrQ2hhbmdlZChzdWJQcm94eURyYWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViUHJveHlEcmFmdC5jb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jb3B5W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0YXJnZXQudHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovIHx8IHRhcmdldC50eXBlID09PSAyIC8qIERyYWZ0VHlwZS5NYXAgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwL1NldCBkcmFmdCBkb2VzIG5vdCBzdXBwb3J0IGFueSBwcm9wZXJ0eSBhc3NpZ25tZW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBfa2V5O1xuICAgICAgICBpZiAodGFyZ2V0LnR5cGUgPT09IDEgLyogRHJhZnRUeXBlLkFycmF5ICovICYmXG4gICAgICAgICAgICBrZXkgIT09ICdsZW5ndGgnICYmXG4gICAgICAgICAgICAhKE51bWJlci5pc0ludGVnZXIoKF9rZXkgPSBOdW1iZXIoa2V5KSkpICYmXG4gICAgICAgICAgICAgICAgX2tleSA+PSAwICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PT0gMCB8fCBfa2V5ID09PSAwIHx8IFN0cmluZyhfa2V5KSA9PT0gU3RyaW5nKGtleSkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yKGxhdGVzdCh0YXJnZXQpLCBrZXkpO1xuICAgICAgICBpZiAoZGVzYyA9PT0gbnVsbCB8fCBkZXNjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXNjLnNldCkge1xuICAgICAgICAgICAgLy8gIWNhc2U6IGNvdmVyIHRoZSBjYXNlIG9mIHNldHRlclxuICAgICAgICAgICAgZGVzYy5zZXQuY2FsbCh0YXJnZXQucHJveHksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwZWVrKGxhdGVzdCh0YXJnZXQpLCBrZXkpO1xuICAgICAgICBjb25zdCBjdXJyZW50UHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQoY3VycmVudCk7XG4gICAgICAgIGlmIChjdXJyZW50UHJveHlEcmFmdCAmJiBpc0VxdWFsKGN1cnJlbnRQcm94eURyYWZ0Lm9yaWdpbmFsLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vICFjYXNlOiBpZ25vcmUgdGhlIGNhc2Ugb2YgYXNzaWduaW5nIHRoZSBvcmlnaW5hbCBkcmFmdGFibGUgdmFsdWUgdG8gYSBkcmFmdFxuICAgICAgICAgICAgdGFyZ2V0LmNvcHlba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwID0gKF9hID0gdGFyZ2V0LmFzc2lnbmVkTWFwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIWNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuICAgICAgICBpZiAoaXNFcXVhbCh2YWx1ZSwgY3VycmVudCkgJiZcbiAgICAgICAgICAgICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGhhcyh0YXJnZXQub3JpZ2luYWwsIGtleSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KHRhcmdldCk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHRhcmdldCk7XG4gICAgICAgIGlmIChoYXModGFyZ2V0Lm9yaWdpbmFsLCBrZXkpICYmIGlzRXF1YWwodmFsdWUsIHRhcmdldC5vcmlnaW5hbFtrZXldKSkge1xuICAgICAgICAgICAgLy8gIWNhc2U6IGhhbmRsZSB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIG9yaWdpbmFsIG5vbi1kcmFmdGFibGUgdmFsdWUgdG8gYSBkcmFmdFxuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLnNldChrZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5jb3B5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgbWFya0ZpbmFsaXphdGlvbih0YXJnZXQsIGtleSwgdmFsdWUsIGdlbmVyYXRlUGF0Y2hlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gbGF0ZXN0KHRhcmdldCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdCh0YXJnZXQpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3QodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdGFyZ2V0LnR5cGUgIT09IDEgLyogRHJhZnRUeXBlLkFycmF5ICovIHx8IGtleSAhPT0gJ2xlbmd0aCcsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogc291cmNlW2tleV0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0Lm9yaWdpbmFsKTtcbiAgICB9LFxuICAgIHNldFByb3RvdHlwZU9mKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjYWxsICdzZXRQcm90b3R5cGVPZigpJyBvbiBkcmFmdHNgKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjYWxsICdkZWZpbmVQcm9wZXJ0eSgpJyBvbiBkcmFmdHNgKTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRhcmdldC50eXBlID09PSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3h5SGFuZGxlci5zZXQuY2FsbCh0aGlzLCB0YXJnZXQsIGtleSwgdW5kZWZpbmVkLCB0YXJnZXQucHJveHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZWVrKHRhcmdldC5vcmlnaW5hbCwga2V5KSAhPT0gdW5kZWZpbmVkIHx8IGtleSBpbiB0YXJnZXQub3JpZ2luYWwpIHtcbiAgICAgICAgICAgIC8vICFjYXNlOiBkZWxldGUgYW4gZXhpc3Rpbmcga2V5XG4gICAgICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAgPSAoX2EgPSB0YXJnZXQuYXNzaWduZWRNYXApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBub24tZXhpc3RlbnQga2V5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmNvcHkpXG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0LmNvcHlba2V5XTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVEcmFmdChjcmVhdGVEcmFmdE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG9yaWdpbmFsLCBwYXJlbnREcmFmdCwga2V5LCBmaW5hbGl0aWVzLCBvcHRpb25zIH0gPSBjcmVhdGVEcmFmdE9wdGlvbnM7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUob3JpZ2luYWwpO1xuICAgIGNvbnN0IHByb3h5RHJhZnQgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGZpbmFsaXplZDogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50RHJhZnQsXG4gICAgICAgIG9yaWdpbmFsLFxuICAgICAgICBjb3B5OiBudWxsLFxuICAgICAgICBwcm94eTogbnVsbCxcbiAgICAgICAgZmluYWxpdGllcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLy8gTWFwcGluZyBvZiBkcmFmdCBTZXQgaXRlbXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBkcmFmdCB2YWx1ZXMuXG4gICAgICAgIHNldE1hcDogdHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovXG4gICAgICAgICAgICA/IG5ldyBNYXAob3JpZ2luYWwuZW50cmllcygpKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICAvLyAhY2FzZTogdW5kZWZpbmVkIGFzIGEgZHJhZnQgbWFwIGtleVxuICAgIGlmIChrZXkgfHwgJ2tleScgaW4gY3JlYXRlRHJhZnRPcHRpb25zKSB7XG4gICAgICAgIHByb3h5RHJhZnQua2V5ID0ga2V5O1xuICAgIH1cbiAgICBjb25zdCB7IHByb3h5LCByZXZva2UgfSA9IFByb3h5LnJldm9jYWJsZSh0eXBlID09PSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLyA/IE9iamVjdC5hc3NpZ24oW10sIHByb3h5RHJhZnQpIDogcHJveHlEcmFmdCwgcHJveHlIYW5kbGVyKTtcbiAgICBmaW5hbGl0aWVzLnJldm9rZS5wdXNoKHJldm9rZSk7XG4gICAgZHJhZnRzQ2FjaGUuYWRkKHByb3h5KTtcbiAgICBwcm94eURyYWZ0LnByb3h5ID0gcHJveHk7XG4gICAgaWYgKHBhcmVudERyYWZ0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHBhcmVudERyYWZ0O1xuICAgICAgICB0YXJnZXQuZmluYWxpdGllcy5kcmFmdC5wdXNoKChwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IG9sZFByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHByb3h5KTtcbiAgICAgICAgICAgIC8vIGlmIHRhcmdldCBpcyBhIFNldCBkcmFmdCwgYHNldE1hcGAgaXMgdGhlIHJlYWwgU2V0IGNvcGllcyBwcm94eSBtYXBwaW5nLlxuICAgICAgICAgICAgbGV0IGNvcHkgPSB0YXJnZXQudHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovID8gdGFyZ2V0LnNldE1hcCA6IHRhcmdldC5jb3B5O1xuICAgICAgICAgICAgY29uc3QgZHJhZnQgPSBnZXQoY29weSwga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KGRyYWZ0KTtcbiAgICAgICAgICAgIGlmIChwcm94eURyYWZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIHRoZSB1cGRhdGVkIHZhbHVlIHRvIHRoZSBjb3B5IG9iamVjdFxuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkVmFsdWUgPSBwcm94eURyYWZ0Lm9yaWdpbmFsO1xuICAgICAgICAgICAgICAgIGlmIChwcm94eURyYWZ0Lm9wZXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRWYWx1ZSA9IGdldFZhbHVlKGRyYWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxpemVTZXRWYWx1ZShwcm94eURyYWZ0KTtcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVBhdGNoZXMocHJveHlEcmFmdCwgZ2VuZXJhdGVQYXRjaGVzLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLmVuYWJsZUF1dG9GcmVlemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm9wdGlvbnMudXBkYXRlZFZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0YXJnZXQub3B0aW9ucy51cGRhdGVkVmFsdWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQub3B0aW9ucy51cGRhdGVkVmFsdWVzLnNldCh1cGRhdGVkVmFsdWUsIHByb3h5RHJhZnQub3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaW5hbCB1cGRhdGUgdmFsdWVcbiAgICAgICAgICAgICAgICBzZXQoY29weSwga2V5LCB1cGRhdGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIWNhc2U6IGhhbmRsZSB0aGUgZGVsZXRlZCBrZXlcbiAgICAgICAgICAgIChfYiA9IG9sZFByb3h5RHJhZnQuY2FsbGJhY2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyAhY2FzZTogaGFuZGxlIHRoZSByb290IGRyYWZ0XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQocHJveHkpO1xuICAgICAgICB0YXJnZXQuZmluYWxpdGllcy5kcmFmdC5wdXNoKChwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykgPT4ge1xuICAgICAgICAgICAgZmluYWxpemVTZXRWYWx1ZSh0YXJnZXQpO1xuICAgICAgICAgICAgZmluYWxpemVQYXRjaGVzKHRhcmdldCwgZ2VuZXJhdGVQYXRjaGVzLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG59XG5pbnRlcm5hbC5jcmVhdGVEcmFmdCA9IGNyZWF0ZURyYWZ0O1xuZnVuY3Rpb24gZmluYWxpemVEcmFmdChyZXN1bHQsIHJldHVybmVkVmFsdWUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBlbmFibGVBdXRvRnJlZXplKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHJlc3VsdCk7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSAoX2EgPSBwcm94eURyYWZ0ID09PSBudWxsIHx8IHByb3h5RHJhZnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3h5RHJhZnQub3JpZ2luYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc3VsdDtcbiAgICBjb25zdCBoYXNSZXR1cm5lZFZhbHVlID0gISFyZXR1cm5lZFZhbHVlLmxlbmd0aDtcbiAgICBpZiAocHJveHlEcmFmdCA9PT0gbnVsbCB8fCBwcm94eURyYWZ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm94eURyYWZ0Lm9wZXJhdGVkKSB7XG4gICAgICAgIHdoaWxlIChwcm94eURyYWZ0LmZpbmFsaXRpZXMuZHJhZnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmluYWxpemUgPSBwcm94eURyYWZ0LmZpbmFsaXRpZXMuZHJhZnQucG9wKCk7XG4gICAgICAgICAgICBmaW5hbGl6ZShwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBoYXNSZXR1cm5lZFZhbHVlXG4gICAgICAgID8gcmV0dXJuZWRWYWx1ZVswXVxuICAgICAgICA6IHByb3h5RHJhZnRcbiAgICAgICAgICAgID8gcHJveHlEcmFmdC5vcGVyYXRlZFxuICAgICAgICAgICAgICAgID8gcHJveHlEcmFmdC5jb3B5XG4gICAgICAgICAgICAgICAgOiBwcm94eURyYWZ0Lm9yaWdpbmFsXG4gICAgICAgICAgICA6IHJlc3VsdDtcbiAgICBpZiAocHJveHlEcmFmdClcbiAgICAgICAgcmV2b2tlUHJveHkocHJveHlEcmFmdCk7XG4gICAgaWYgKGVuYWJsZUF1dG9GcmVlemUpIHtcbiAgICAgICAgZGVlcEZyZWV6ZShzdGF0ZSwgc3RhdGUsIHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcHRpb25zLnVwZGF0ZWRWYWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGF0Y2hlcyAmJiBoYXNSZXR1cm5lZFZhbHVlXG4gICAgICAgICAgICA/IFt7IG9wOiBPcGVyYXRpb24uUmVwbGFjZSwgcGF0aDogW10sIHZhbHVlOiByZXR1cm5lZFZhbHVlWzBdIH1dXG4gICAgICAgICAgICA6IHBhdGNoZXMsXG4gICAgICAgIGludmVyc2VQYXRjaGVzICYmIGhhc1JldHVybmVkVmFsdWVcbiAgICAgICAgICAgID8gW3sgb3A6IE9wZXJhdGlvbi5SZXBsYWNlLCBwYXRoOiBbXSwgdmFsdWU6IG9yaWdpbmFsIH1dXG4gICAgICAgICAgICA6IGludmVyc2VQYXRjaGVzLFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIGRyYWZ0aWZ5KGJhc2VTdGF0ZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBmaW5hbGl0aWVzID0ge1xuICAgICAgICBkcmFmdDogW10sXG4gICAgICAgIHJldm9rZTogW10sXG4gICAgICAgIGhhbmRsZWRTZXQ6IG5ldyBXZWFrU2V0KCksXG4gICAgfTtcbiAgICBsZXQgcGF0Y2hlcztcbiAgICBsZXQgaW52ZXJzZVBhdGNoZXM7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlUGF0Y2hlcykge1xuICAgICAgICBwYXRjaGVzID0gW107XG4gICAgICAgIGludmVyc2VQYXRjaGVzID0gW107XG4gICAgfVxuICAgIGNvbnN0IGlzTXV0YWJsZSA9ICgoX2EgPSBvcHRpb25zLm1hcmspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGJhc2VTdGF0ZSwgZGF0YVR5cGVzKSkgPT09IGRhdGFUeXBlcy5tdXRhYmxlIHx8XG4gICAgICAgICFpc0RyYWZ0YWJsZShiYXNlU3RhdGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRyYWZ0ID0gaXNNdXRhYmxlXG4gICAgICAgID8gYmFzZVN0YXRlXG4gICAgICAgIDogY3JlYXRlRHJhZnQoe1xuICAgICAgICAgICAgb3JpZ2luYWw6IGJhc2VTdGF0ZSxcbiAgICAgICAgICAgIHBhcmVudERyYWZ0OiBudWxsLFxuICAgICAgICAgICAgZmluYWxpdGllcyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGRyYWZ0LFxuICAgICAgICAocmV0dXJuZWRWYWx1ZSA9IFtdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbZmluYWxpemVkU3RhdGUsIGZpbmFsaXplZFBhdGNoZXMsIGZpbmFsaXplZEludmVyc2VQYXRjaGVzXSA9IGZpbmFsaXplRHJhZnQoZHJhZnQsIHJldHVybmVkVmFsdWUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBvcHRpb25zLmVuYWJsZUF1dG9GcmVlemUpO1xuICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zLmVuYWJsZVBhdGNoZXNcbiAgICAgICAgICAgICAgICA/IFtmaW5hbGl6ZWRTdGF0ZSwgZmluYWxpemVkUGF0Y2hlcywgZmluYWxpemVkSW52ZXJzZVBhdGNoZXNdXG4gICAgICAgICAgICAgICAgOiBmaW5hbGl6ZWRTdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmV0dXJuVmFsdWUob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vdERyYWZ0LCB2YWx1ZSwgdXNlUmF3UmV0dXJuID0gZmFsc2UsIGlzUm9vdCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgZm9yRWFjaCh2YWx1ZSwgKGtleSwgaXRlbSwgc291cmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KGl0ZW0pO1xuICAgICAgICAvLyBqdXN0IGhhbmRsZSB0aGUgZHJhZnQgd2hpY2ggaXMgY3JlYXRlZCBieSB0aGUgc2FtZSByb290RHJhZnRcbiAgICAgICAgaWYgKHByb3h5RHJhZnQgJiZcbiAgICAgICAgICAgIHJvb3REcmFmdCAmJlxuICAgICAgICAgICAgcHJveHlEcmFmdC5maW5hbGl0aWVzID09PSByb290RHJhZnQuZmluYWxpdGllcykge1xuICAgICAgICAgICAgb3B0aW9ucy5pc0NvbnRhaW5EcmFmdCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBwcm94eURyYWZ0Lm9yaWdpbmFsO1xuICAgICAgICAgICAgLy8gZmluYWwgdXBkYXRlIHZhbHVlLCBidXQganVzdCBoYW5kbGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gQXJyYXkuZnJvbShzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGFyci5mb3JFYWNoKChfaXRlbSkgPT4gc291cmNlLmFkZChrZXkgPT09IF9pdGVtID8gY3VycmVudFZhbHVlIDogX2l0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldChzb3VyY2UsIGtleSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IGl0ZW07XG4gICAgICAgICAgICBvcHRpb25zLmlzUm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgaGFuZGxlUmV0dXJuVmFsdWUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5pc0NvbnRhaW5EcmFmdClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIHJldHVybiB2YWx1ZSBkb2VzIG5vdCBjb250YWluIGFueSBkcmFmdCwgcGxlYXNlIHVzZSAncmF3UmV0dXJuKCknIHRvIHdyYXAgdGhlIHJldHVybiB2YWx1ZSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmApO1xuICAgICAgICBpZiAodXNlUmF3UmV0dXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgZHJhZnRzLCBwbGVhc2UgZG9uJ3QgdXNlICdyYXdSZXR1cm4oKScgdG8gd3JhcCB0aGUgcmV0dXJuIHZhbHVlLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VycmVudCh0YXJnZXQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodGFyZ2V0KTtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKHRhcmdldCwgcHJveHlEcmFmdCA9PT0gbnVsbCB8fCBwcm94eURyYWZ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm94eURyYWZ0Lm9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHRhcmdldCk7XG4gICAgaWYgKHByb3h5RHJhZnQgJiYgIXByb3h5RHJhZnQub3BlcmF0ZWQpXG4gICAgICAgIHJldHVybiBwcm94eURyYWZ0Lm9yaWdpbmFsO1xuICAgIGxldCBjdXJyZW50VmFsdWU7XG4gICAgZnVuY3Rpb24gZW5zdXJlU2hhbGxvd0NvcHkoKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9XG4gICAgICAgICAgICB0eXBlID09PSAyIC8qIERyYWZ0VHlwZS5NYXAgKi9cbiAgICAgICAgICAgICAgICA/ICFpc0Jhc2VNYXBJbnN0YW5jZSh0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KS5jb25zdHJ1Y3RvcikodGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBNYXAodGFyZ2V0KVxuICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gMyAvKiBEcmFmdFR5cGUuU2V0ICovXG4gICAgICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShwcm94eURyYWZ0LnNldE1hcC52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgOiBzaGFsbG93Q29weSh0YXJnZXQsIHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHByb3h5RHJhZnQpIHtcbiAgICAgICAgLy8gSXQncyBhIHByb3h5IGRyYWZ0LCBsZXQncyBjcmVhdGUgYSBzaGFsbG93IGNvcHkgZWFnZXJseVxuICAgICAgICBwcm94eURyYWZ0LmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbnN1cmVTaGFsbG93Q29weSgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcHJveHlEcmFmdC5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBub3QgYSBwcm94eSBkcmFmdCwgbGV0J3MgdXNlIHRoZSB0YXJnZXQgZGlyZWN0bHkgYW5kIGxldCdzIHNlZVxuICAgICAgICAvLyBsYXppbHkgaWYgd2UgbmVlZCB0byBjcmVhdGUgYSBzaGFsbG93IGNvcHlcbiAgICAgICAgY3VycmVudFZhbHVlID0gdGFyZ2V0O1xuICAgIH1cbiAgICBmb3JFYWNoKGN1cnJlbnRWYWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHByb3h5RHJhZnQgJiYgaXNFcXVhbChnZXQocHJveHlEcmFmdC5vcmlnaW5hbCwga2V5KSwgdmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldEN1cnJlbnQodmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkoKTtcbiAgICAgICAgICAgIHNldChjdXJyZW50VmFsdWUsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfYSA9IHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcmlnaW5hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VycmVudFZhbHVlO1xuICAgICAgICByZXR1cm4gIWlzQmFzZVNldEluc3RhbmNlKHZhbHVlKVxuICAgICAgICAgICAgPyBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IpKGN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAgIDogbmV3IFNldChjdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFZhbHVlO1xufVxuZnVuY3Rpb24gY3VycmVudCh0YXJnZXQpIHtcbiAgICBpZiAoIWlzRHJhZnQodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGN1cnJlbnQoKSBpcyBvbmx5IHVzZWQgZm9yIERyYWZ0LCBwYXJhbWV0ZXI6ICR7dGFyZ2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q3VycmVudCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIGBtYWtlQ3JlYXRvcihvcHRpb25zKWAgdG8gbWFrZSBhIGNyZWF0b3IgZnVuY3Rpb24uXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBtYWtlQ3JlYXRvciB9IGZyb20gJy4uL2luZGV4JztcbiAqXG4gKiBjb25zdCBiYXNlU3RhdGUgPSB7IGZvbzogeyBiYXI6ICdzdHInIH0sIGFycjogW10gfTtcbiAqIGNvbnN0IGNyZWF0ZSA9IG1ha2VDcmVhdG9yKHsgZW5hYmxlQXV0b0ZyZWV6ZTogdHJ1ZSB9KTtcbiAqIGNvbnN0IHN0YXRlID0gY3JlYXRlKFxuICogICBiYXNlU3RhdGUsXG4gKiAgIChkcmFmdCkgPT4ge1xuICogICAgIGRyYWZ0LmZvby5iYXIgPSAnc3RyMic7XG4gKiAgIH0sXG4gKiApO1xuICpcbiAqIGV4cGVjdChzdGF0ZSkudG9FcXVhbCh7IGZvbzogeyBiYXI6ICdzdHIyJyB9LCBhcnI6IFtdIH0pO1xuICogZXhwZWN0KHN0YXRlKS5ub3QudG9CZShiYXNlU3RhdGUpO1xuICogZXhwZWN0KHN0YXRlLmZvbykubm90LnRvQmUoYmFzZVN0YXRlLmZvbyk7XG4gKiBleHBlY3Qoc3RhdGUuYXJyKS50b0JlKGJhc2VTdGF0ZS5hcnIpO1xuICogZXhwZWN0KE9iamVjdC5pc0Zyb3plbihzdGF0ZSkpLnRvQmVUcnV0aHkoKTtcbiAqIGBgYFxuICovXG5jb25zdCBtYWtlQ3JlYXRvciA9IChhcmcpID0+IHtcbiAgICBpZiAoYXJnICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvcHRpb25zOiAke1N0cmluZyhhcmcpfSwgJ29wdGlvbnMnIHNob3VsZCBiZSBhbiBvYmplY3QuYCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGUoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmcxICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKGJhc2UsIChkcmFmdCkgPT4gYXJnMC5jYWxsKHRoaXMsIGRyYWZ0LCAuLi5hcmdzKSwgYXJnMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2UgPSBhcmcwO1xuICAgICAgICBjb25zdCBtdXRhdGUgPSBhcmcxO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9wdGlvbnM6ICR7b3B0aW9uc30sICdvcHRpb25zJyBzaG91bGQgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFyZyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGlzRHJhZnQoYmFzZSkgPyBjdXJyZW50KGJhc2UpIDogYmFzZTtcbiAgICAgICAgY29uc3QgbWFyayA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXJrKVxuICAgICAgICAgICAgPyAoKHZhbHVlLCB0eXBlcykgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWFyayBvZiBvcHRpb25zLm1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXJrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWFyazogJHttYXJrfSwgJ21hcmsnIHNob3VsZCBiZSBhIGZ1bmN0aW9uLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hcmsodmFsdWUsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBvcHRpb25zLm1hcms7XG4gICAgICAgIGNvbnN0IGVuYWJsZVBhdGNoZXMgPSAoX2EgPSBvcHRpb25zLmVuYWJsZVBhdGNoZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBzdHJpY3QgPSAoX2IgPSBvcHRpb25zLnN0cmljdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGVuYWJsZUF1dG9GcmVlemUgPSAoX2MgPSBvcHRpb25zLmVuYWJsZUF1dG9GcmVlemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xuICAgICAgICBjb25zdCBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVuYWJsZUF1dG9GcmVlemUsXG4gICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgZW5hYmxlUGF0Y2hlcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc0RyYWZ0YWJsZShzdGF0ZSwgX29wdGlvbnMpICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3RhdGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhc2Ugc3RhdGU6IGNyZWF0ZSgpIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBTZXQsIE1hcCBvciB1c2luZyBtYXJrKCkgdG8gbWFyayB0aGUgc3RhdGUgYXMgaW1tdXRhYmxlLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtkcmFmdCwgZmluYWxpemVdID0gZHJhZnRpZnkoc3RhdGUsIF9vcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIWlzRHJhZnRhYmxlKHN0YXRlLCBfb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmFzZSBzdGF0ZTogY3JlYXRlKCkgb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3RzLCBhcnJheXMsIFNldCwgTWFwIG9yIHVzaW5nIG1hcmsoKSB0byBtYXJrIHRoZSBzdGF0ZSBhcyBpbW11dGFibGUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2RyYWZ0LCBmaW5hbGl6ZV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG11dGF0ZShkcmFmdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXZva2VQcm94eShnZXRQcm94eURyYWZ0KGRyYWZ0KSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQoZHJhZnQpO1xuICAgICAgICAgICAgaWYgKCFpc0RyYWZ0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0VxdWFsKHZhbHVlLCBkcmFmdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcGVyYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFaXRoZXIgdGhlIHZhbHVlIGlzIHJldHVybmVkIGFzIGEgbmV3IG5vbi1kcmFmdCB2YWx1ZSwgb3Igb25seSB0aGUgZHJhZnQgaXMgbW9kaWZpZWQgd2l0aG91dCByZXR1cm5pbmcgYW55IHZhbHVlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYXdSZXR1cm5WYWx1ZSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVtSQVdfUkVUVVJOX1NZTUJPTF07XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF92YWx1ZSA9IHJhd1JldHVyblZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX29wdGlvbnMuc3RyaWN0ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVJldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RHJhZnQ6IHByb3h5RHJhZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlUmF3UmV0dXJuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplKFtfdmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVJldHVyblZhbHVlKHsgcm9vdERyYWZ0OiBwcm94eURyYWZ0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxpemUoW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBkcmFmdCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldHVybmVkUHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zID09PSByZXR1cm5lZFByb3h5RHJhZnQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZFByb3h5RHJhZnQub3BlcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmV0dXJuIGEgbW9kaWZpZWQgY2hpbGQgZHJhZnQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZShbY3VycmVudCh2YWx1ZSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZShbdmFsdWVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZXR1cm5WYWx1ZSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV2b2tlUHJveHkoZ2V0UHJveHlEcmFmdChkcmFmdCkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlKHJlc3VsdCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogYGNyZWF0ZShiYXNlU3RhdGUsIGNhbGxiYWNrLCBvcHRpb25zKWAgdG8gY3JlYXRlIHRoZSBuZXh0IHN0YXRlXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICcuLi9pbmRleCc7XG4gKlxuICogY29uc3QgYmFzZVN0YXRlID0geyBmb286IHsgYmFyOiAnc3RyJyB9LCBhcnI6IFtdIH07XG4gKiBjb25zdCBzdGF0ZSA9IGNyZWF0ZShcbiAqICAgYmFzZVN0YXRlLFxuICogICAoZHJhZnQpID0+IHtcbiAqICAgICBkcmFmdC5mb28uYmFyID0gJ3N0cjInO1xuICogICB9LFxuICogKTtcbiAqXG4gKiBleHBlY3Qoc3RhdGUpLnRvRXF1YWwoeyBmb286IHsgYmFyOiAnc3RyMicgfSwgYXJyOiBbXSB9KTtcbiAqIGV4cGVjdChzdGF0ZSkubm90LnRvQmUoYmFzZVN0YXRlKTtcbiAqIGV4cGVjdChzdGF0ZS5mb28pLm5vdC50b0JlKGJhc2VTdGF0ZS5mb28pO1xuICogZXhwZWN0KHN0YXRlLmFycikudG9CZShiYXNlU3RhdGUuYXJyKTtcbiAqIGBgYFxuICovXG5jb25zdCBjcmVhdGUgPSBtYWtlQ3JlYXRvcigpO1xuXG4vKipcbiAqIGBhcHBseShzdGF0ZSwgcGF0Y2hlcylgIHRvIGFwcGx5IHBhdGNoZXMgdG8gc3RhdGVcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZSwgYXBwbHkgfSBmcm9tICcuLi9pbmRleCc7XG4gKlxuICogY29uc3QgYmFzZVN0YXRlID0geyBmb286IHsgYmFyOiAnc3RyJyB9LCBhcnI6IFtdIH07XG4gKiBjb25zdCBbc3RhdGUsIHBhdGNoZXNdID0gY3JlYXRlKFxuICogICBiYXNlU3RhdGUsXG4gKiAgIChkcmFmdCkgPT4ge1xuICogICAgIGRyYWZ0LmZvby5iYXIgPSAnc3RyMic7XG4gKiAgIH0sXG4gKiAgIHsgZW5hYmxlUGF0Y2hlczogdHJ1ZSB9XG4gKiApO1xuICogZXhwZWN0KHN0YXRlKS50b0VxdWFsKHsgZm9vOiB7IGJhcjogJ3N0cjInIH0sIGFycjogW10gfSk7XG4gKiBleHBlY3QocGF0Y2hlcykudG9FcXVhbChbeyBvcDogJ3JlcGxhY2UnLCBwYXRoOiBbJ2ZvbycsICdiYXInXSwgdmFsdWU6ICdzdHIyJyB9XSk7XG4gKiBleHBlY3Qoc3RhdGUpLnRvRXF1YWwoYXBwbHkoYmFzZVN0YXRlLCBwYXRjaGVzKSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXBwbHkoc3RhdGUsIHBhdGNoZXMsIGFwcGx5T3B0aW9ucykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHBhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgb3AsIHBhdGggfSA9IHBhdGNoZXNbaV07XG4gICAgICAgIGlmICgoIXBhdGgubGVuZ3RoICYmIG9wID09PSBPcGVyYXRpb24uUmVwbGFjZSkgfHxcbiAgICAgICAgICAgIChwYXRoID09PSAnJyAmJiBvcCA9PT0gT3BlcmF0aW9uLkFkZCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG4gICAgY29uc3QgbXV0YXRlID0gKGRyYWZ0KSA9PiB7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aDogX3BhdGgsIG9wIH0gPSBwYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB1bmVzY2FwZVBhdGgoX3BhdGgpO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBkcmFmdDtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXRoLmxlbmd0aCAtIDE7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0VHlwZShiYXNlKTtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IFN0cmluZyhrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChwYXJlbnRUeXBlID09PSAwIC8qIERyYWZ0VHlwZS5PYmplY3QgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHlwZSA9PT0gMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgYmFzZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXkgPT09ICdwcm90b3R5cGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGNoaW5nIHJlc2VydmVkIGF0dHJpYnV0ZXMgbGlrZSBfX3Byb3RvX18gYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1c2UgYGluZGV4YCBpbiBTZXQgZHJhZnRcbiAgICAgICAgICAgICAgICBiYXNlID0gZ2V0KHBhcmVudFR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyA/IEFycmF5LmZyb20oYmFzZSkgOiBiYXNlLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgcGF0Y2ggYXQgJyR7cGF0aC5qb2luKCcvJyl9Jy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShiYXNlKTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgb3JpZ2luYWwgcGF0Y2ggaXMgbm90IG1vZGlmaWVkLlxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ2xvbmUocGF0Y2gudmFsdWUpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0aW9uLlJlcGxhY2U6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIERyYWZ0VHlwZS5NYXAgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIERyYWZ0VHlwZS5TZXQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgcmVwbGFjZSBwYXRjaCB0byBzZXQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmFzZVtrZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRpb24uQWRkOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIFwiLVwiIGNoYXJhY3RlciBpcyB1c2VkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdGhlIGVuZCBvZiB0aGUgYXJyYXkgKHNlZSBbUkZDNjkwMV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2OTAyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBhcHBlbmRpbmcgdGhlIHZhbHVlIHRvIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSAnLSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBiYXNlLnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYmFzZS5zcGxpY2Uoa2V5LCAwLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogRHJhZnRUeXBlLk1hcCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogRHJhZnRUeXBlLlNldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0aW9uLlJlbW92ZTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogRHJhZnRUeXBlLkFycmF5ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIERyYWZ0VHlwZS5NYXAgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogRHJhZnRUeXBlLlNldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiAke29wfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoaXNEcmFmdChzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGFwcGx5T3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhcHBseSBwYXRjaGVzIHdpdGggb3B0aW9ucyB0byBhIGRyYWZ0LmApO1xuICAgICAgICB9XG4gICAgICAgIG11dGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZShzdGF0ZSwgbXV0YXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFwcGx5T3B0aW9ucyksIHsgZW5hYmxlUGF0Y2hlczogZmFsc2UgfSkpO1xufVxuXG4vKipcbiAqIGBvcmlnaW5hbChkcmFmdClgIHRvIGdldCBvcmlnaW5hbCBzdGF0ZSBpbiB0aGUgZHJhZnQgbXV0YXRpb24gZnVuY3Rpb24uXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGUsIG9yaWdpbmFsIH0gZnJvbSAnLi4vaW5kZXgnO1xuICpcbiAqIGNvbnN0IGJhc2VTdGF0ZSA9IHsgZm9vOiB7IGJhcjogJ3N0cicgfSwgYXJyOiBbXSB9O1xuICogY29uc3Qgc3RhdGUgPSBjcmVhdGUoXG4gKiAgIGJhc2VTdGF0ZSxcbiAqICAgKGRyYWZ0KSA9PiB7XG4gKiAgICAgZHJhZnQuZm9vLmJhciA9ICdzdHIyJztcbiAqICAgICBleHBlY3Qob3JpZ2luYWwoZHJhZnQuZm9vKSkudG9FcXVhbCh7IGJhcjogJ3N0cicgfSk7XG4gKiAgIH1cbiAqICk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gb3JpZ2luYWwodGFyZ2V0KSB7XG4gICAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodGFyZ2V0KTtcbiAgICBpZiAoIXByb3h5RHJhZnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcmlnaW5hbCgpIGlzIG9ubHkgdXNlZCBmb3IgYSBkcmFmdCwgcGFyYW1ldGVyOiAke3RhcmdldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5RHJhZnQub3JpZ2luYWw7XG59XG5cbi8qKlxuICogVXNlIHJhd1JldHVybigpIHRvIHdyYXAgdGhlIHJldHVybiB2YWx1ZSB0byBza2lwIHRoZSBkcmFmdCBjaGVjayBhbmQgdGh1cyBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlLCByYXdSZXR1cm4gfSBmcm9tICcuLi9pbmRleCc7XG4gKlxuICogY29uc3QgYmFzZVN0YXRlID0geyBmb286IHsgYmFyOiAnc3RyJyB9LCBhcnI6IFtdIH07XG4gKiBjb25zdCBzdGF0ZSA9IGNyZWF0ZShcbiAqICAgYmFzZVN0YXRlLFxuICogICAoZHJhZnQpID0+IHtcbiAqICAgICByZXR1cm4gcmF3UmV0dXJuKGJhc2VTdGF0ZSk7XG4gKiAgIH0sXG4gKiApO1xuICogZXhwZWN0KHN0YXRlKS50b0JlKGJhc2VTdGF0ZSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmF3UmV0dXJuKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXdSZXR1cm4oKSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgdmFsdWUuJyk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jhd1JldHVybigpIG11c3QgYmUgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdyYXdSZXR1cm4oKSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdChpbmNsdWRpbmcgcGxhaW4gb2JqZWN0LCBhcnJheXMsIFNldCwgTWFwLCBldGMuKSBvciBgdW5kZWZpbmVkYCwgb3RoZXIgdHlwZXMgZG8gbm90IG5lZWQgdG8gYmUgcmV0dXJuZWQgdmlhIHJhd1JldHVybigpLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBbUkFXX1JFVFVSTl9TWU1CT0xdOiBbdmFsdWVdLFxuICAgIH07XG59XG5cbmNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYSBzaW1wbGUgb2JqZWN0KE5vIHByb3RvdHlwZSBjaGFpbiBvYmplY3Qgb3IgaWZyYW1lIHNhbWUtb3JpZ2luIG9iamVjdCksXG4gKiBzdXBwb3J0IGNhc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS91bmFkbGliL211dGF0aXZlL2lzc3Vlcy8xN1xuICovXG5jb25zdCBpc1NpbXBsZU9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm90b3R5cGUsICdjb25zdHJ1Y3RvcicpICYmXG4gICAgICAgIHByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgRnVuY3Rpb24udG9TdHJpbmcuY2FsbChjb25zdHJ1Y3RvcikgPT09IGNvbnN0cnVjdG9yU3RyaW5nKTtcbn07XG5jb25zdCBtYXJrU2ltcGxlT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU2ltcGxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGF0YVR5cGVzLmltbXV0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBDYXN0IGEgdmFsdWUgdG8gYW4gRHJhZnQgdHlwZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY2FzdERyYWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBDYXN0IGEgdmFsdWUgdG8gYW4gSW1tdXRhYmxlIHR5cGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIENhc3QgYSB2YWx1ZSB0byBhbiBNdXRhYmxlIHR5cGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhc3RNdXRhYmxlKGRyYWZ0KSB7XG4gICAgcmV0dXJuIGRyYWZ0O1xufVxuXG5leHBvcnQgeyBhcHBseSwgY2FzdERyYWZ0LCBjYXN0SW1tdXRhYmxlLCBjYXN0TXV0YWJsZSwgY3JlYXRlLCBjdXJyZW50LCBpc0RyYWZ0LCBpc0RyYWZ0YWJsZSwgbWFrZUNyZWF0b3IsIG1hcmtTaW1wbGVPYmplY3QsIG9yaWdpbmFsLCByYXdSZXR1cm4sIHVuc2FmZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpdmUuZXNtLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mutative/dist/mutative.esm.mjs\n");

/***/ })

};
;